<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Safety Analytics Platform - Amazon WHS | Developed by Erwin Esener</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        :root {
            --primary: #4caf50;
            --primary-dark: #388e3c;
            --secondary: #232F3E;
            --secondary-dark: #37475A;
            --success: #4CAF50;
            --warning: #FFC107;
            --danger: #FF5722;
            --critical: #B71C1C;
            --bg-primary: #ffffff;
            --bg-secondary: #f5f5f5;
            --text-primary: #212121;
            --text-secondary: #757575;
            --shadow: rgba(0,0,0,0.1);
            --shadow-hover: rgba(0,0,0,0.15);
            --border-radius: 12px;
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        [data-theme="dark"] {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --shadow: rgba(255,255,255,0.05);
            --shadow-hover: rgba(255,255,255,0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            line-height: 1.6;
            transition: var(--transition);
        }

        /* Modern Header */
        .header {
            background: linear-gradient(135deg, var(--secondary) 0%, var(--secondary-dark) 100%);
            color: white;
            padding: 1.5rem 0;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 4px 20px var(--shadow);
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 1.5rem;
        }

        .logo-container {
            display: flex;
            align-items: center;
            height: 40px;
        }

        .whs-logo {
            font-size: 3rem;
            font-weight: 900;
            color: var(--primary);
            letter-spacing: -2px;
            margin: 0;
            line-height: 1;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .header-title {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .header h1 {
            font-size: 1.8rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .header-subtitle {
            font-size: 0.9rem;
            opacity: 0.9;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .header-actions {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        /* Mode Toggle */
        .mode-toggle {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 30px;
            padding: 0.5rem 1rem;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: var(--transition);
        }

        .mode-toggle:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }

        /* Navigation Tabs */
        .nav-container {
            background: var(--bg-primary);
            box-shadow: 0 2px 10px var(--shadow);
            position: sticky;
            top: 80px;
            z-index: 90;
            margin-bottom: 2rem;
        }

        .nav-tabs {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0.75rem 20px;
            display: flex;
            gap: 0.5rem;
            overflow-x: auto;
            scrollbar-width: thin;
        }

        .nav-tab {
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            transition: var(--transition);
            white-space: nowrap;
            font-weight: 500;
            position: relative;
            overflow: hidden;
            background: var(--bg-secondary);
        }

        .nav-tab::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 0;
            height: 100%;
            background: var(--primary);
            transition: width 0.3s;
            z-index: -1;
        }

        .nav-tab:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px var(--shadow);
        }

        .nav-tab:hover::before {
            width: 100%;
        }

        .nav-tab.active {
            background: var(--primary);
            color: white;
            box-shadow: 0 4px 10px rgba(76, 175, 80, 0.3);
        }

        .nav-tab-icon {
            margin-right: 0.5rem;
        }

        /* Container */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px 40px;
        }

        /* Modern Cards */
        .card {
            background: var(--bg-primary);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            box-shadow: 0 2px 10px var(--shadow);
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: var(--primary);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 25px var(--shadow-hover);
        }

        .card:hover::before {
            opacity: 1;
        }

        /* Metrics Grid */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .metric-card {
            background: var(--bg-primary);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            position: relative;
            overflow: hidden;
            box-shadow: 0 2px 10px var(--shadow);
            transition: var(--transition);
        }

        .metric-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 25px var(--shadow-hover);
        }

        .metric-icon {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            margin-bottom: 1rem;
            transition: var(--transition);
        }

        .metric-card:hover .metric-icon {
            transform: scale(1.1) rotate(5deg);
        }

        .metric-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--text-primary);
            margin: 0.5rem 0;
            transition: var(--transition);
        }

        .metric-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .metric-trend {
            position: absolute;
            top: 1.5rem;
            right: 1.5rem;
            font-size: 0.9rem;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            background: rgba(76, 175, 80, 0.1);
            color: var(--success);
        }

        .metric-trend.down {
            background: rgba(255, 87, 34, 0.1);
            color: var(--danger);
        }

        /* Control Panel */
        .control-panel {
            background: var(--bg-primary);
            border-radius: var(--border-radius);
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 2px 10px var(--shadow);
        }

        .control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .control-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Modern Buttons */
        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255,255,255,0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn:active::before {
            width: 300px;
            height: 300px;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }

        .btn-secondary {
            background: var(--secondary);
            color: white;
        }

        .btn-secondary:hover {
            background: var(--secondary-dark);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(35, 47, 62, 0.3);
        }

        .btn-outline {
            background: transparent;
            border: 2px solid var(--primary);
            color: var(--primary);
        }

        .btn-outline:hover {
            background: var(--primary);
            color: white;
            transform: translateY(-2px);
        }

        .btn-sm {
            padding: 0.5rem 1rem;
            font-size: 0.85rem;
        }

        /* File Upload Area */
        .upload-area {
            border: 2px dashed var(--primary);
            border-radius: var(--border-radius);
            padding: 2rem;
            text-align: center;
            transition: var(--transition);
            background: rgba(76, 175, 80, 0.05);
            margin-bottom: 1.5rem;
        }

        .upload-area:hover {
            border-color: var(--primary-dark);
            background: rgba(76, 175, 80, 0.1);
        }

        .upload-area.dragging {
            background: rgba(76, 175, 80, 0.2);
            border-color: var(--primary);
        }

        .file-input {
            display: none;
        }

        .upload-label {
            display: inline-block;
            padding: 0.75rem 2rem;
            background: var(--primary);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: var(--transition);
            font-weight: 500;
        }

        .upload-label:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
        }

        /* Filter Section */
        .filter-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .filter-label {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .filter-input {
            padding: 0.75rem;
            border: 2px solid transparent;
            border-radius: 8px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            transition: var(--transition);
            font-size: 0.95rem;
        }

        .filter-input:focus {
            outline: none;
            border-color: var(--primary);
            background: var(--bg-primary);
        }

        /* Quick Actions Bar */
        .quick-actions {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        /* Charts Container */
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .chart-card {
            background: var(--bg-primary);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            box-shadow: 0 2px 10px var(--shadow);
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .chart-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .chart-container {
            position: relative;
            height: 300px;
        }

        /* Data Table */
        .table-container {
            background: var(--bg-primary);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            box-shadow: 0 2px 10px var(--shadow);
            overflow: hidden;
        }

        .table-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .table-wrapper {
            overflow-x: auto;
            margin: -1.5rem;
            padding: 1.5rem;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th {
            background: var(--secondary);
            color: white;
            padding: 1rem;
            text-align: left;
            font-weight: 500;
            position: sticky;
            top: 0;
            z-index: 10;
            white-space: nowrap;
        }

        td {
            padding: 1rem;
            border-bottom: 1px solid var(--bg-secondary);
            color: var(--text-primary);
        }

        tr:hover {
            background: var(--bg-secondary);
        }

        /* Badges */
        .badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .badge-success {
            background: rgba(76, 175, 80, 0.2);
            color: var(--success);
        }

        .badge-warning {
            background: rgba(255, 193, 7, 0.2);
            color: var(--warning);
        }

        .badge-danger {
            background: rgba(255, 87, 34, 0.2);
            color: var(--danger);
        }

        .badge-critical {
            background: rgba(183, 28, 28, 0.2);
            color: var(--critical);
        }

        .badge-info {
            background: rgba(33, 150, 243, 0.2);
            color: #2196F3;
        }

        /* Risk Matrix */
        .risk-matrix {
            display: grid;
            grid-template-columns: 80px repeat(5, 1fr);
            grid-template-rows: repeat(6, 80px);
            gap: 4px;
            max-width: 600px;
            margin: 2rem auto;
        }

        .matrix-cell {
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            color: white;
            cursor: pointer;
            transition: var(--transition);
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            font-size: 1.1rem;
        }

        .matrix-cell::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255,255,255,0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.4s, height 0.4s;
        }

        .matrix-cell:hover::before {
            width: 100px;
            height: 100px;
        }

        .matrix-cell:hover {
            transform: scale(1.05);
            z-index: 10;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .matrix-label {
            background: var(--secondary);
            color: white;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .risk-low { background: var(--success); }
        .risk-medium { background: var(--warning); color: #333; }
        .risk-high { background: var(--danger); }
        .risk-critical { background: var(--critical); }

        /* Timeline */
        .timeline-container {
            background: var(--bg-primary);
            border-radius: var(--border-radius);
            padding: 2rem;
            box-shadow: 0 2px 10px var(--shadow);
        }

        .timeline-item {
            border-left: 3px solid var(--primary);
            padding-left: 2rem;
            margin-bottom: 2rem;
            position: relative;
        }

        .timeline-item::before {
            content: '';
            position: absolute;
            left: -8px;
            top: 0;
            width: 13px;
            height: 13px;
            border-radius: 50%;
            background: var(--primary);
        }

        .timeline-date {
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 0.5rem;
        }

        .timeline-content {
            background: var(--bg-secondary);
            padding: 1rem;
            border-radius: 8px;
        }

        /* Status Messages */
        .status-message {
            padding: 1rem 1.5rem;
            border-radius: 8px;
            margin: 1rem 0;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-10px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .status-success {
            background: rgba(76, 175, 80, 0.1);
            color: var(--success);
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .status-error {
            background: rgba(255, 87, 34, 0.1);
            color: var(--danger);
            border: 1px solid rgba(255, 87, 34, 0.3);
        }

        .status-info {
            background: rgba(33, 150, 243, 0.1);
            color: #2196F3;
            border: 1px solid rgba(33, 150, 243, 0.3);
        }

        /* EHS System Link */
        .austin-link {
            background: var(--primary);
            color: white;
            padding: 0.4rem 0.8rem;
            border-radius: 5px;
            text-decoration: none;
            font-size: 0.85rem;
            transition: var(--transition);
            margin-left: 0.5rem;
        }

        .austin-link:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
        }

        /* Loading Spinner */
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid var(--bg-secondary);
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 2rem auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Action Items */
        .action-section {
            background: var(--bg-primary);
            border-radius: var(--border-radius);
            padding: 2rem;
            box-shadow: 0 2px 10px var(--shadow);
        }

        .action-category {
            margin-bottom: 2rem;
        }

        .action-category h4 {
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .action-list {
            list-style: none;
            padding: 0;
        }

        .action-item {
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            transition: var(--transition);
        }

        .action-item:hover {
            transform: translateX(4px);
        }

        .action-icon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }

        .action-icon.immediate {
            background: rgba(255, 87, 34, 0.2);
            color: var(--danger);
        }

        .action-icon.short-term {
            background: rgba(255, 193, 7, 0.2);
            color: var(--warning);
        }

        .action-icon.long-term {
            background: rgba(33, 150, 243, 0.2);
            color: #2196F3;
        }

        /* Quality Analysis Specific Styles */
        .quality-metric {
            background: var(--bg-secondary);
            padding: 1.5rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            border-left: 4px solid var(--primary);
        }

        .quality-score {
            font-size: 3rem;
            font-weight: 700;
            margin: 1rem 0;
        }

        .quality-score.good {
            color: var(--success);
        }

        .quality-score.medium {
            color: var(--warning);
        }

        .quality-score.poor {
            color: var(--danger);
        }

        .quality-indicator {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin: 0.5rem 0;
        }

        .quality-indicator-label {
            flex: 1;
            font-weight: 500;
        }

        .quality-indicator-value {
            font-weight: 700;
        }

        .duplicate-list {
            max-height: 300px;
            overflow-y: auto;
            background: var(--bg-secondary);
            padding: 1rem;
            border-radius: 8px;
            margin-top: 1rem;
        }

        .duplicate-item {
            padding: 0.5rem;
            border-bottom: 1px solid var(--bg-primary);
        }

        .duplicate-item:last-child {
            border-bottom: none;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                text-align: center;
            }

            .header-left {
                flex-direction: column;
                gap: 1rem;
            }

            .whs-logo {
                font-size: 2.5rem;
            }

            .nav-tabs {
                flex-wrap: nowrap;
                overflow-x: scroll;
            }

            .charts-grid {
                grid-template-columns: 1fr;
            }

            .filter-section {
                grid-template-columns: 1fr;
            }

            .table-wrapper {
                font-size: 0.9rem;
            }

            .risk-matrix {
                grid-template-columns: 40px repeat(5, 1fr);
                grid-template-rows: repeat(6, 60px);
                font-size: 0.8rem;
            }
        }

        /* Tab Content */
        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease-out;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Hidden class */
        .hidden {
            display: none !important;
        }

        /* Export Options */
        .export-section {
            background: var(--bg-primary);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            margin-top: 2rem;
            box-shadow: 0 2px 10px var(--shadow);
        }

        .export-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            animation: fadeIn 0.3s;
        }

        .modal-content {
            position: relative;
            background: var(--bg-primary);
            margin: 5% auto;
            padding: 2rem;
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            border-radius: var(--border-radius);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            animation: slideDown 0.3s;
        }

        @keyframes slideDown {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid var(--bg-secondary);
            padding-bottom: 1rem;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-secondary);
            transition: var(--transition);
        }

        .modal-close:hover {
            color: var(--text-primary);
            transform: rotate(90deg);
        }

        /* Welcome Screen */
        .welcome-screen {
            text-align: center;
            padding: 4rem 2rem;
        }

        .welcome-title {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .welcome-subtitle {
            font-size: 1.2rem;
            color: var(--text-secondary);
            margin-bottom: 3rem;
        }

        .welcome-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        /* Pagination */
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .pagination-info {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        /* KPI Dashboard */
        .kpi-container {
            background: linear-gradient(135deg, var(--secondary) 0%, var(--secondary-dark) 100%);
            color: white;
            border-radius: var(--border-radius);
            padding: 2rem;
            margin-bottom: 2rem;
        }

        .kpi-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 2rem;
            margin-top: 1.5rem;
        }

        .kpi-item {
            text-align: center;
        }

        .kpi-value {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        .kpi-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }
            
            .header, .nav-container, .mode-toggle, .btn, .upload-area {
                display: none !important;
            }
            
            .card, .table-container {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #ddd;
            }
        }

        /* Footer */
        .footer {
            background: var(--secondary);
            color: white;
            padding: 2rem 0;
            margin-top: 4rem;
            text-align: center;
            font-size: 0.9rem;
        }

        .footer a {
            color: var(--primary);
            text-decoration: none;
        }

        .footer a:hover {
            text-decoration: underline;
        }

        /* Sub Navigation */
        .sub-nav {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid var(--bg-secondary);
            padding-bottom: 0.5rem;
        }

        .sub-nav-item {
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: var(--transition);
            border-radius: 8px 8px 0 0;
        }

        .sub-nav-item:hover {
            background: var(--bg-secondary);
        }

        .sub-nav-item.active {
            background: var(--primary);
            color: white;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-content">
            <div class="header-left">
                <div class="logo-container">
                    <div class="whs-logo">WHS</div>
                </div>
                <div class="header-title">
                    <h1>
                        <span>🛡️</span>
                        Safety Analytics Platform
                    </h1>
                    <div class="header-subtitle">
                        <span>Amazon Workplace Health & Safety</span>
                        <span style="opacity: 0.7;">|</span>
                        <span>Developed by Erwin Esener</span>
                    </div>
                </div>
            </div>
            <div class="header-actions">
                <button class="mode-toggle" onclick="toggleTheme()">
                    <span id="themeIcon">🌙</span>
                    <span id="themeText">Dark Mode</span>
                </button>
            </div>
        </div>
    </header>

    <!-- Navigation -->
    <nav class="nav-container">
        <div class="nav-tabs">
            <div class="nav-tab active" onclick="switchModule('overview')">
                <span class="nav-tab-icon">📊</span>
                <span>Overview</span>
            </div>
            <div class="nav-tab" onclick="switchModule('injury')">
                <span class="nav-tab-icon">🏥</span>
                <span>Injury & Illness</span>
            </div>
            <div class="nav-tab" onclick="switchModule('nearmiss')">
                <span class="nav-tab-icon">⚠️</span>
                <span>Near Miss</span>
            </div>
            <div class="nav-tab" onclick="switchModule('combined')">
                <span class="nav-tab-icon">📈</span>
                <span>Combined Analytics</span>
            </div>
            <div class="nav-tab" onclick="switchModule('reports')">
                <span class="nav-tab-icon">📄</span>
                <span>Reports</span>
            </div>
            <div class="nav-tab" onclick="switchModule('actions')">
                <span class="nav-tab-icon">✅</span>
                <span>Action Tracking</span>
            </div>
        </div>
    </nav>

    <div class="container">
        <!-- Status Message Container -->
        <div id="statusContainer"></div>

        <!-- Overview Module -->
        <div id="overview" class="tab-content active">
            <div class="welcome-screen" id="welcomeScreen">
                <h2 class="welcome-title">Welcome to Safety Analytics</h2>
                <p class="welcome-subtitle">Your comprehensive platform for workplace safety data analysis</p>
                <div class="welcome-actions">
                    <button class="btn btn-primary" onclick="switchModule('injury')">
                        <span>🏥</span> Analyze Injuries
                    </button>
                    <button class="btn btn-primary" onclick="switchModule('nearmiss')">
                        <span>⚠️</span> Review Near Misses
                    </button>
                    <button class="btn btn-secondary" onclick="loadSampleData()">
                        <span>🧪</span> Load Sample Data
                    </button>
                </div>
            </div>

            <!-- KPI Dashboard -->
            <div class="kpi-container" id="kpiDashboard" style="display: none;">
                <h3>Key Performance Indicators - Safety Metrics</h3>
                <div class="kpi-grid">
                    <div class="kpi-item">
                        <div class="kpi-value" id="kpiTRIR">0.00</div>
                        <div class="kpi-label">TRIR (Total Recordable Incident Rate)</div>
                    </div>
                    <div class="kpi-item">
                        <div class="kpi-value" id="kpiLTIR">0.00</div>
                        <div class="kpi-label">LTIR (Lost Time Incident Rate)</div>
                    </div>
                    <div class="kpi-item">
                        <div class="kpi-value" id="kpiDAFWR">0.00</div>
                        <div class="kpi-label">DAFWR (Days Away From Work Rate)</div>
                    </div>
                    <div class="kpi-item">
                        <div class="kpi-value" id="kpiNMFR">0.00</div>
                        <div class="kpi-label">NMFR (Near Miss Frequency Rate)</div>
                    </div>
                </div>
            </div>

            <!-- Combined Metrics Overview -->
            <div class="metrics-grid" id="overviewMetrics" style="display: none;">
                <div class="metric-card">
                    <div class="metric-icon">📊</div>
                    <div class="metric-value" id="totalIncidents">0</div>
                    <div class="metric-label">Total Safety Events</div>
                    <div class="metric-trend">↓ 12%</div>
                </div>
                <div class="metric-card">
                    <div class="metric-icon">🏥</div>
                    <div class="metric-value" id="injuryCount">0</div>
                    <div class="metric-label">Injuries & Illnesses</div>
                </div>
                <div class="metric-card">
                    <div class="metric-icon">⚠️</div>
                    <div class="metric-value" id="nearMissCount">0</div>
                    <div class="metric-label">Near Misses</div>
                </div>
                <div class="metric-card">
                    <div class="metric-icon">📈</div>
                    <div class="metric-value" id="riskScore">0.0</div>
                    <div class="metric-label">Overall Risk Score</div>
                </div>
            </div>

            <!-- Quick Charts -->
            <div class="charts-grid" id="overviewCharts" style="display: none;">
                <div class="chart-card">
                    <div class="chart-header">
                        <h3 class="chart-title">Safety Trend Overview</h3>
                        <button class="btn btn-sm btn-outline" onclick="exportChart('overviewTrendChart')">
                            <span>📸</span> Export
                        </button>
                    </div>
                    <div class="chart-container">
                        <canvas id="overviewTrendChart"></canvas>
                    </div>
                </div>
                <div class="chart-card">
                    <div class="chart-header">
                        <h3 class="chart-title">Site Comparison</h3>
                        <button class="btn btn-sm btn-outline" onclick="exportChart('overviewSiteChart')">
                            <span>📸</span> Export
                        </button>
                    </div>
                    <div class="chart-container">
                        <canvas id="overviewSiteChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Injury & Illness Module -->
        <div id="injury" class="tab-content">
            <!-- Sub Navigation -->
            <div class="sub-nav">
                <div class="sub-nav-item active" onclick="switchInjuryView('dashboard')">Dashboard</div>
                <div class="sub-nav-item" onclick="switchInjuryView('riskMatrix')">Risk Matrix</div>
                <div class="sub-nav-item" onclick="switchInjuryView('timeline')">Timeline</div>
                <div class="sub-nav-item" onclick="switchInjuryView('analytics')">Advanced Analytics</div>
            </div>

            <!-- Dashboard View -->
            <div id="injuryDashboard" class="injury-view">
                <div class="control-panel">
                    <div class="control-header">
                        <h2 class="control-title">Injury & Illness Analysis</h2>
                        <div class="quick-actions">
                            <button class="btn btn-primary" onclick="generatePDFReport('injury')">
                                <span>📄</span> Generate Report
                            </button>
                            <button class="btn btn-secondary" onclick="exportInjuryData()">
                                <span>📊</span> Export to Excel
                            </button>
                            <button class="btn btn-outline" onclick="refreshDashboard('injury')">
                                <span>🔄</span> Refresh
                            </button>
                        </div>
                    </div>

                    <div class="upload-area" id="injuryUploadArea" ondrop="handleDrop(event, 'injury')" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                        <p style="margin-bottom: 1rem;">📁 Drag and drop your injury CSV file here</p>
                        <label for="injuryFile" class="upload-label">Choose File</label>
                        <input type="file" id="injuryFile" class="file-input" accept=".csv" onchange="handleFileUpload(event, 'injury')">
                        <p style="margin-top: 1rem; font-size: 0.9rem; color: var(--text-secondary);">
                            Supports CSV files with injury/illness tracking data including severity, body parts, causes, recordability, and OTR status
                        </p>
                    </div>

                    <div class="filter-section">
                        <div class="filter-group">
                            <label class="filter-label">Site</label>
                            <select class="filter-input" id="injurySiteFilter" onchange="applyFilters('injury')">
                                <option value="">All Sites</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Severity</label>
                            <select class="filter-input" id="injurySeverityFilter" onchange="applyFilters('injury')">
                                <option value="">All Severities</option>
                                <option value="A">A - Critical</option>
                                <option value="B">B - High</option>
                                <option value="C">C - Medium</option>
                                <option value="D">D - Low</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Recordable</label>
                            <select class="filter-input" id="injuryRecordableFilter" onchange="applyFilters('injury')">
                                <option value="">All Cases</option>
                                <option value="1">Recordable Only</option>
                                <option value="0">Non-Recordable Only</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">OTR Status</label>
                            <select class="filter-input" id="injuryOTRFilter" onchange="applyFilters('injury')">
                                <option value="">All</option>
                                <option value="yes">On The Road</option>
                                <option value="no">Not On The Road</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Body Part</label>
                            <select class="filter-input" id="injuryBodyPartFilter" onchange="applyFilters('injury')">
                                <option value="">All Body Parts</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Root Cause</label>
                            <select class="filter-input" id="injuryRootCauseFilter" onchange="applyFilters('injury')">
                                <option value="">All Causes</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Date From</label>
                            <input type="date" class="filter-input" id="injuryDateFrom" onchange="applyFilters('injury')">
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Date To</label>
                            <input type="date" class="filter-input" id="injuryDateTo" onchange="applyFilters('injury')">
                        </div>
                    </div>
                </div>

                <!-- Injury Metrics -->
                <div class="metrics-grid" id="injuryMetrics">
                    <div class="metric-card">
                        <div class="metric-icon">🏥</div>
                        <div class="metric-value" id="injuryTotal">0</div>
                        <div class="metric-label">Total Incidents</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">📝</div>
                        <div class="metric-value" id="injuryRecordable">0</div>
                        <div class="metric-label">Recordable Cases</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">📅</div>
                        <div class="metric-value" id="injuryLostTime">0</div>
                        <div class="metric-label">Lost Time Cases</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">⏱️</div>
                        <div class="metric-value" id="injuryDaysLost">0</div>
                        <div class="metric-label">Days Away From Work</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">🚗</div>
                        <div class="metric-value" id="injuryOTR">0</div>
                        <div class="metric-label">OTR Incidents</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">📊</div>
                        <div class="metric-value" id="injuryRecordableRate">0.0</div>
                        <div class="metric-label">Recordable Rate</div>
                    </div>
                </div>

                <!-- Injury Charts -->
                <div class="charts-grid">
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Analysis View 1</h3>
                            <select class="filter-input" style="width: auto;" onchange="updateInjuryChart(1, this.value)">
                                <option value="severity">Severity Distribution</option>
                                <option value="bodyPart">Body Parts Affected</option>
                                <option value="rootCause">Root Causes</option>
                                <option value="processPath">Process Paths</option>
                                <option value="contributingFactors">Contributing Factors</option>
                                <option value="otrAnalysis">OTR Analysis</option>
                            </select>
                        </div>
                        <div class="chart-container">
                            <canvas id="injuryChart1"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Analysis View 2</h3>
                            <select class="filter-input" style="width: auto;" onchange="updateInjuryChart(2, this.value)">
                                <option value="trend">Monthly Trend</option>
                                <option value="recordableTrend">Recordable Trend</option>
                                <option value="lostTimeTrend">Lost Time Trend</option>
                                <option value="dafwAnalysis">DAFW Analysis</option>
                            </select>
                        </div>
                        <div class="chart-container">
                            <canvas id="injuryChart2"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Site Analysis</h3>
                            <select class="filter-input" style="width: auto;" onchange="updateInjuryChart(3, this.value)">
                                <option value="site">Site Comparison</option>
                                <option value="recordableRate">Recordable Rate by Site</option>
                                <option value="severityBySite">Severity by Site</option>
                            </select>
                        </div>
                        <div class="chart-container">
                            <canvas id="injuryChart3"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Impact Analysis</h3>
                            <select class="filter-input" style="width: auto;" onchange="updateInjuryChart(4, this.value)">
                                <option value="impactType">Impact Types</option>
                                <option value="bodyPartHeatmap">Body Part Heatmap</option>
                                <option value="riskTrend">Risk Score Trend</option>
                            </select>
                        </div>
                        <div class="chart-container">
                            <canvas id="injuryChart4"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Injury Table -->
                <div class="table-container">
                    <div class="table-header">
                        <h3>Recent Injury & Illness Cases</h3>
                        <button class="btn btn-sm btn-outline" onclick="exportTable('injury')">
                            <span>📊</span> Export Table
                        </button>
                    </div>
                    <div class="table-wrapper">
                        <table id="injuryTable">
                            <thead>
                                <tr>
                                    <th>Case Number</th>
                                    <th>Date</th>
                                    <th>Site</th>
                                    <th>Body Part</th>
                                    <th>Type</th>
                                    <th>Severity</th>
                                    <th>Recordable</th>
                                    <th>OTR</th>
                                    <th>DAFW Days</th>
                                    <th>Root Cause</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="injuryTableBody">
                                <tr>
                                    <td colspan="11" style="text-align: center; padding: 3rem;">
                                        No data loaded. Please upload a CSV file.
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <div class="pagination">
                        <button class="btn btn-sm" onclick="changePage('injury', -1)" id="injuryPrevBtn">Previous</button>
                        <span class="pagination-info" id="injuryPageInfo">Page 1 of 1</span>
                        <button class="btn btn-sm" onclick="changePage('injury', 1)" id="injuryNextBtn">Next</button>
                    </div>
                </div>
            </div>

            <!-- Risk Matrix View -->
            <div id="injuryRiskMatrix" class="injury-view hidden">
                <div class="card">
                    <h3 style="margin-bottom: 1.5rem;">Injury & Illness Risk Assessment Matrix</h3>
                    <p style="color: var(--text-secondary); margin-bottom: 1rem;">
                        Click on any cell to view incidents in that risk category
                    </p>
                    <div class="risk-matrix" id="injuryRiskMatrixGrid">
                        <!-- Will be populated dynamically -->
                    </div>
                    <div style="margin-top: 2rem; text-align: center;">
                        <h4>Risk Levels:</h4>
                        <div style="display: flex; gap: 2rem; justify-content: center; margin-top: 1rem;">
                            <span><span style="display: inline-block; width: 20px; height: 20px; background: #4CAF50; vertical-align: middle; border-radius: 4px;"></span> Low (1-5)</span>
                            <span><span style="display: inline-block; width: 20px; height: 20px; background: #FFC107; vertical-align: middle; border-radius: 4px;"></span> Medium (6-10)</span>
                            <span><span style="display: inline-block; width: 20px; height: 20px; background: #FF5722; vertical-align: middle; border-radius: 4px;"></span> High (11-15)</span>
                            <span><span style="display: inline-block; width: 20px; height: 20px; background: #B71C1C; vertical-align: middle; border-radius: 4px;"></span> Critical (16-25)</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Timeline View -->
            <div id="injuryTimeline" class="injury-view hidden">
                <div class="timeline-container">
                    <h3 style="margin-bottom: 1.5rem;">Injury & Illness Timeline</h3>
                    <div id="injuryTimelineContent">
                        <p style="text-align: center; padding: 2rem;">Timeline will be displayed after data is loaded.</p>
                    </div>
                    <div class="pagination">
                        <button class="btn btn-sm" onclick="changeTimelinePage('injury', -1)">Previous</button>
                        <span class="pagination-info" id="injuryTimelinePageInfo">Page 1 of 1</span>
                        <button class="btn btn-sm" onclick="changeTimelinePage('injury', 1)">Next</button>
                    </div>
                </div>
            </div>

            <!-- Advanced Analytics View -->
            <div id="injuryAnalytics" class="injury-view hidden">
                <div class="charts-grid">
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Recordable Rate Trend</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="injuryRecordableRateTrendChart"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Body Part Heat Map by Severity</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="injuryBodyPartHeatMapChart"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Root Cause Analysis by Site</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="injuryRootCauseBySiteChart"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">DAFW Days Distribution</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="injuryDAFWDistributionChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Near Miss Module -->
        <div id="nearmiss" class="tab-content">
            <!-- Sub Navigation -->
            <div class="sub-nav">
                <div class="sub-nav-item active" onclick="switchNearMissView('dashboard')">Dashboard</div>
                <div class="sub-nav-item" onclick="switchNearMissView('riskMatrix')">Risk Matrix</div>
                <div class="sub-nav-item" onclick="switchNearMissView('timeline')">Timeline</div>
                <div class="sub-nav-item" onclick="switchNearMissView('analytics')">Advanced Analytics</div>
                <div class="sub-nav-item" onclick="switchNearMissView('quality')">Quality Analysis</div>
            </div>

            <!-- Dashboard View -->
            <div id="nearMissDashboard" class="nearmiss-view">
                <div class="control-panel">
                    <div class="control-header">
                        <h2 class="control-title">Near Miss Analysis</h2>
                        <div class="quick-actions">
                            <button class="btn btn-primary" onclick="generatePDFReport('nearmiss')">
                                <span>📄</span> Generate Report
                            </button>
                            <button class="btn btn-secondary" onclick="exportNearMissData()">
                                <span>📊</span> Export to Excel
                            </button>
                            <button class="btn btn-outline" onclick="refreshDashboard('nearmiss')">
                                <span>🔄</span> Refresh
                            </button>
                        </div>
                    </div>

                    <div class="upload-area" id="nearMissUploadArea" ondrop="handleDrop(event, 'nearmiss')" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                        <p style="margin-bottom: 1rem;">📁 Drag and drop your near miss CSV file here</p>
                        <label for="nearMissFile" class="upload-label">Choose File</label>
                        <input type="file" id="nearMissFile" class="file-input" accept=".csv" onchange="handleFileUpload(event, 'nearmiss')">
                        <p style="margin-top: 1rem; font-size: 0.9rem; color: var(--text-secondary);">
                            Supports CSV files with near miss tracking data including potential severity, location, and risk assessments
                        </p>
                    </div>

                    <div class="filter-section">
                        <div class="filter-group">
                            <label class="filter-label">Site</label>
                            <select class="filter-input" id="nearMissSiteFilter" onchange="applyFilters('nearmiss')">
                                <option value="">All Sites</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Potential Severity</label>
                            <select class="filter-input" id="nearMissSeverityFilter" onchange="applyFilters('nearmiss')">
                                <option value="">All Severities</option>
                                <option value="A">A - Critical</option>
                                <option value="B">B - High</option>
                                <option value="C">C - Medium</option>
                                <option value="D">D - Low</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Primary Impact</label>
                            <select class="filter-input" id="nearMissPrimaryImpactFilter" onchange="applyFilters('nearmiss')">
                                <option value="">All Impacts</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Location</label>
                            <select class="filter-input" id="nearMissLocationFilter" onchange="applyFilters('nearmiss')">
                                <option value="">All Locations</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Process Path</label>
                            <select class="filter-input" id="nearMissProcessFilter" onchange="applyFilters('nearmiss')">
                                <option value="">All Processes</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Likelihood</label>
                            <select class="filter-input" id="nearMissLikelihoodFilter" onchange="applyFilters('nearmiss')">
                                <option value="">All Likelihoods</option>
                                <option value="Rare">Rare</option>
                                <option value="Unlikely">Unlikely</option>
                                <option value="Possible">Possible</option>
                                <option value="Likely">Likely</option>
                                <option value="Almost Certain">Almost Certain</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Date From</label>
                            <input type="date" class="filter-input" id="nearMissDateFrom" onchange="applyFilters('nearmiss')">
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Date To</label>
                            <input type="date" class="filter-input" id="nearMissDateTo" onchange="applyFilters('nearmiss')">
                        </div>
                    </div>
                </div>

                <!-- Near Miss Metrics -->
                <div class="metrics-grid" id="nearMissMetrics">
                    <div class="metric-card">
                        <div class="metric-icon">⚠️</div>
                        <div class="metric-value" id="nearMissTotal">0</div>
                        <div class="metric-label">Total Near Misses</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">📊</div>
                        <div class="metric-value" id="nearMissRisk">0.0</div>
                        <div class="metric-label">Average Risk Score</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">🚨</div>
                        <div class="metric-value" id="nearMissHigh">0</div>
                        <div class="metric-label">High Severity (A & B)</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">📍</div>
                        <div class="metric-value" id="nearMissRepeat">0</div>
                        <div class="metric-label">Repeat Locations</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">⚡</div>
                        <div class="metric-value" id="nearMissActionable">0</div>
                        <div class="metric-label">Requires Action</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-icon">📈</div>
                        <div class="metric-value" id="nearMissFrequency">0.0</div>
                        <div class="metric-label">Frequency Rate</div>
                    </div>
                </div>

                <!-- Near Miss Charts -->
                <div class="charts-grid">
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Analysis View 1</h3>
                            <select class="filter-input" style="width: auto;" onchange="updateNearMissChart(1, this.value)">
                                <option value="severity">Severity Distribution</option>
                                <option value="location">Top Locations</option>
                                <option value="impact">Primary Impacts</option>
                                <option value="likelihood">Likelihood Analysis</option>
                            </select>
                        </div>
                        <div class="chart-container">
                            <canvas id="nearMissChart1"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Analysis View 2</h3>
                            <select class="filter-input" style="width: auto;" onchange="updateNearMissChart(2, this.value)">
                                <option value="process">Process Paths</option>
                                <option value="trend">Monthly Trend</option>
                                <option value="site">Site Comparison</option>
                                <option value="riskTrend">Risk Score Trend</option>
                            </select>
                        </div>
                        <div class="chart-container">
                            <canvas id="nearMissChart2"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Impact Analysis</h3>
                            <select class="filter-input" style="width: auto;" onchange="updateNearMissChart(3, this.value)">
                                <option value="impactBySeverity">Impact by Severity</option>
                                <option value="locationHeatmap">Location Heatmap</option>
                                <option value="contributingFactors">Contributing Factors</option>
                            </select>
                        </div>
                        <div class="chart-container">
                            <canvas id="nearMissChart3"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Risk Analysis</h3>
                            <select class="filter-input" style="width: auto;" onchange="updateNearMissChart(4, this.value)">
                                <option value="riskMatrix">Risk Score Distribution</option>
                                <option value="highRiskAreas">High Risk Areas</option>
                                <option value="preventionOpportunities">Prevention Opportunities</option>
                            </select>
                        </div>
                        <div class="chart-container">
                            <canvas id="nearMissChart4"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Near Miss Table -->
                <div class="table-container">
                    <div class="table-header">
                        <h3>Recent Near Miss Reports</h3>
                        <button class="btn btn-sm btn-outline" onclick="exportTable('nearmiss')">
                            <span>📊</span> Export Table
                        </button>
                    </div>
                    <div class="table-wrapper">
                        <table id="nearMissTable">
                            <thead>
                                <tr>
                                    <th>Near Miss ID</th>
                                    <th>Date</th>
                                    <th>Site</th>
                                    <th>Location</th>
                                    <th>Process Path</th>
                                    <th>Primary Impact</th>
                                    <th>Severity</th>
                                    <th>Likelihood</th>
                                    <th>Risk Score</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="nearMissTableBody">
                                <tr>
                                    <td colspan="10" style="text-align: center; padding: 3rem;">
                                        No data loaded. Please upload a CSV file.
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <div class="pagination">
                        <button class="btn btn-sm" onclick="changePage('nearmiss', -1)" id="nearMissPrevBtn">Previous</button>
                        <span class="pagination-info" id="nearMissPageInfo">Page 1 of 1</span>
                        <button class="btn btn-sm" onclick="changePage('nearmiss', 1)" id="nearMissNextBtn">Next</button>
                    </div>
                </div>
            </div>

            <!-- Risk Matrix View -->
            <div id="nearMissRiskMatrix" class="nearmiss-view hidden">
                <div class="card">
                    <h3 style="margin-bottom: 1.5rem;">Near Miss Risk Assessment Matrix</h3>
                    <p style="color: var(--text-secondary); margin-bottom: 1rem;">
                        Click on any cell to view incidents in that risk category
                    </p>
                    <div class="risk-matrix" id="nearMissRiskMatrixGrid">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>
            </div>

            <!-- Timeline View -->
            <div id="nearMissTimeline" class="nearmiss-view hidden">
                <div class="timeline-container">
                    <h3 style="margin-bottom: 1.5rem;">Near Miss Timeline</h3>
                    <div id="nearMissTimelineContent">
                        <p style="text-align: center; padding: 2rem;">Timeline will be displayed after data is loaded.</p>
                    </div>
                    <div class="pagination">
                        <button class="btn btn-sm" onclick="changeTimelinePage('nearmiss', -1)">Previous</button>
                        <span class="pagination-info" id="nearMissTimelinePageInfo">Page 1 of 1</span>
                        <button class="btn btn-sm" onclick="changeTimelinePage('nearmiss', 1)">Next</button>
                    </div>
                </div>
            </div>

            <!-- Advanced Analytics View -->
            <div id="nearMissAnalytics" class="nearmiss-view hidden">
                <div class="charts-grid">
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Risk Trend Analysis</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="nearMissRiskTrendChart"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Impact vs Severity Analysis</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="nearMissImpactAnalysisChart"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Location Risk Map</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="nearMissLocationRiskChart"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <h3 class="chart-title">Process Path Risk Analysis</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="nearMissProcessRiskChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Quality Analysis View -->
            <div id="nearMissQuality" class="nearmiss-view hidden">
                <div class="card">
                    <h3 style="margin-bottom: 1.5rem;">Near Miss Data Quality Analysis</h3>
                    
                    <!-- Overall Quality Score -->
                    <div class="quality-metric">
                        <h4>Overall Data Quality Score</h4>
                        <div class="quality-score" id="overallQualityScore">--%</div>
                        <p style="color: var(--text-secondary);">Based on description length, uniqueness, completeness, and data integrity</p>
                    </div>

                    <!-- Quality Metrics Grid -->
                    <div class="metrics-grid">
                        <div class="metric-card">
                            <div class="metric-icon">📝</div>
                            <div class="metric-value" id="avgDescLength">0</div>
                            <div class="metric-label">Avg Description Length</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-icon">📋</div>
                            <div class="metric-value" id="duplicateCount">0</div>
                            <div class="metric-label">Duplicate Descriptions</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-icon">⚠️</div>
                            <div class="metric-value" id="shortDescCount">0</div>
                            <div class="metric-label">Short Descriptions (&lt;50 chars)</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-icon">✅</div>
                            <div class="metric-value" id="completeRecords">0%</div>
                            <div class="metric-label">Complete Records</div>
                        </div>
                    </div>

                    <!-- Quality Indicators -->
                    <div class="card" style="margin-top: 2rem;">
                        <h4 style="margin-bottom: 1rem;">Quality Indicators</h4>
                        
                        <div class="quality-indicator">
                            <span class="quality-indicator-label">Description Quality</span>
                            <span class="quality-indicator-value" id="descQualityIndicator">-</span>
                        </div>
                        
                        <div class="quality-indicator">
                            <span class="quality-indicator-label">Data Completeness</span>
                            <span class="quality-indicator-value" id="completenessIndicator">-</span>
                        </div>
                        
                        <div class="quality-indicator">
                            <span class="quality-indicator-label">Duplicate Detection</span>
                            <span class="quality-indicator-value" id="duplicateIndicator">-</span>
                        </div>
                        
                        <div class="quality-indicator">
                            <span class="quality-indicator-label">Risk Assessment Quality</span>
                            <span class="quality-indicator-value" id="riskQualityIndicator">-</span>
                        </div>
                    </div>

                    <!-- Detailed Analysis Charts -->
                    <div class="charts-grid" style="margin-top: 2rem;">
                        <div class="chart-card">
                            <div class="chart-header">
                                <h3 class="chart-title">Description Length Distribution</h3>
                            </div>
                            <div class="chart-container">
                                <canvas id="descLengthChart"></canvas>
                            </div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-header">
                                <h3 class="chart-title">Quality by Site</h3>
                            </div>
                            <div class="chart-container">
                                <canvas id="qualityBySiteChart"></canvas>
                            </div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-header">
                                <h3 class="chart-title">Common Phrases Analysis</h3>
                            </div>
                            <div class="chart-container">
                                <canvas id="commonPhrasesChart"></canvas>
                            </div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-header">
                                <h3 class="chart-title">Quality Trend Over Time</h3>
                            </div>
                            <div class="chart-container">
                                <canvas id="qualityTrendChart"></canvas>
                            </div>
                        </div>
                    </div>

                    <!-- Duplicate Descriptions List -->
                    <div class="card" style="margin-top: 2rem;">
                        <h4 style="margin-bottom: 1rem;">Duplicate Descriptions Found</h4>
                        <div class="duplicate-list" id="duplicateList">
                            <p style="color: var(--text-secondary);">No duplicates found</p>
                        </div>
                    </div>

                    <!-- Quality Improvement Recommendations -->
                    <div class="card" style="margin-top: 2rem;">
                        <h4 style="margin-bottom: 1rem;">Quality Improvement Recommendations</h4>
                        <div id="qualityRecommendations">
                            <p style="color: var(--text-secondary);">Recommendations will appear after data analysis</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Combined Analytics Module -->
        <div id="combined" class="tab-content">
            <div class="control-panel">
                <div class="control-header">
                    <h2 class="control-title">Combined Safety Analytics</h2>
                    <div>
                        <button class="btn btn-primary" onclick="generatePDFReport('combined')">
                            <span>📄</span> Generate Combined Report
                        </button>
                    </div>
                </div>
            </div>

            <!-- Combined Metrics -->
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-icon">📊</div>
                    <div class="metric-value" id="combinedTotal">0</div>
                    <div class="metric-label">Total Safety Events</div>
                </div>
                <div class="metric-card">
                    <div class="metric-icon">⚠️</div>
                    <div class="metric-value" id="combinedHighRisk">0</div>
                    <div class="metric-label">High Risk Events</div>
                </div>
                <div class="metric-card">
                    <div class="metric-icon">📈</div>
                    <div class="metric-value" id="combinedTrend">0%</div>
                    <div class="metric-label">Monthly Trend</div>
                </div>
                <div class="metric-card">
                    <div class="metric-icon">🎯</div>
                    <div class="metric-value" id="combinedTargetSites">0</div>
                    <div class="metric-label">Sites Requiring Focus</div>
                </div>
            </div>

            <!-- Risk Matrix -->
            <div class="card">
                <h3 style="margin-bottom: 1.5rem;">Combined Risk Assessment Matrix</h3>
                <div class="risk-matrix" id="combinedRiskMatrix">
                    <!-- Will be populated dynamically -->
                </div>
            </div>

            <!-- Combined Charts -->
            <div class="charts-grid">
                <div class="chart-card">
                    <div class="chart-header">
                        <h3 class="chart-title">Safety Performance Trend</h3>
                    </div>
                    <div class="chart-container">
                        <canvas id="combinedTrendChart"></canvas>
                    </div>
                </div>
                <div class="chart-card">
                    <div class="chart-header">
                        <h3 class="chart-title">Site Safety Comparison</h3>
                    </div>
                    <div class="chart-container">
                        <canvas id="combinedSiteChart"></canvas>
                    </div>
                </div>
                <div class="chart-card">
                    <div class="chart-header">
                        <h3 class="chart-title">Severity Analysis - Combined</h3>
                    </div>
                    <div class="chart-container">
                        <canvas id="combinedSeverityChart"></canvas>
                    </div>
                </div>
                <div class="chart-card">
                    <div class="chart-header">
                        <h3 class="chart-title">Prevention Effectiveness</h3>
                    </div>
                    <div class="chart-container">
                        <canvas id="combinedPreventionChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Insights -->
            <div class="card" style="margin-top: 2rem;">
                <h3 style="margin-bottom: 1.5rem;">Key Insights & Correlations</h3>
                <div id="combinedInsights">
                    <p style="color: var(--text-secondary);">Load data to see insights and correlations between injuries and near misses</p>
                </div>
            </div>
        </div>

        <!-- Reports Module -->
        <div id="reports" class="tab-content">
            <div class="control-panel">
                <div class="control-header">
                    <h2 class="control-title">Report Generation Center</h2>
                </div>
            </div>

            <div class="export-section">
                <h3 style="margin-bottom: 1.5rem;">Available Reports</h3>
                <div class="export-grid">
                    <button class="btn btn-primary" onclick="generatePDFReport('injury')">
                        <span>📄</span> 
                        <div>
                            <div>Injury & Illness Report</div>
                            <small style="font-size: 0.8rem; opacity: 0.8;">Comprehensive injury analysis</small>
                        </div>
                    </button>
                    <button class="btn btn-primary" onclick="generatePDFReport('nearmiss')">
                        <span>📄</span>
                        <div>
                            <div>Near Miss Report</div>
                            <small style="font-size: 0.8rem; opacity: 0.8;">Near miss trends & patterns</small>
                        </div>
                    </button>
                    <button class="btn btn-primary" onclick="generatePDFReport('combined')">
                        <span>📄</span>
                        <div>
                            <div>Combined Safety Report</div>
                            <small style="font-size: 0.8rem; opacity: 0.8;">Full safety analysis</small>
                        </div>
                    </button>
                    <button class="btn btn-primary" onclick="generatePDFReport('executive')">
                        <span>📄</span>
                        <div>
                            <div>Executive Summary</div>
                            <small style="font-size: 0.8rem; opacity: 0.8;">High-level overview</small>
                        </div>
                    </button>
                    <button class="btn btn-secondary" onclick="exportToExcel('all')">
                        <span>📊</span>
                        <div>
                            <div>Export All Data to Excel</div>
                            <small style="font-size: 0.8rem; opacity: 0.8;">Raw data export</small>
                        </div>
                    </button>
                    <button class="btn btn-secondary" onclick="exportDashboard()">
                        <span>📸</span>
                        <div>
                            <div>Dashboard Screenshot</div>
                            <small style="font-size: 0.8rem; opacity: 0.8;">Current view capture</small>
                        </div>
                    </button>
                </div>
            </div>

            <div class="card" style="margin-top: 2rem;">
                <h3 style="margin-bottom: 1.5rem;">Report History</h3>
                <div id="reportHistory">
                    <p style="color: var(--text-secondary);">No reports generated yet</p>
                </div>
            </div>

            <div class="card" style="margin-top: 2rem;">
                <h3 style="margin-bottom: 1.5rem;">Scheduled Reports</h3>
                <div style="display: flex; gap: 1rem; align-items: center;">
                    <select class="filter-input" style="flex: 1;">
                        <option>Weekly Safety Summary - Every Monday</option>
                        <option>Monthly Executive Report - 1st of Month</option>
                        <option>Quarterly Trend Analysis - Quarterly</option>
                    </select>
                    <button class="btn btn-outline">Configure</button>
                </div>
            </div>
        </div>

        <!-- Action Tracking Module -->
        <div id="actions" class="tab-content">
            <div class="control-panel">
                <div class="control-header">
                    <h2 class="control-title">Action Item Tracking</h2>
                    <button class="btn btn-primary" onclick="addNewAction()">
                        <span>➕</span> Add Action
                    </button>
                </div>
            </div>

            <div class="action-section">
                <div class="action-category">
                    <h4 style="color: var(--danger);">
                        <span class="action-icon immediate">🚨</span>
                        Immediate Actions Required
                    </h4>
                    <ul class="action-list" id="immediateActions">
                        <li class="action-item">
                            <span class="action-icon immediate">!</span>
                            <div style="flex: 1;">
                                <strong>No immediate actions identified</strong>
                                <p style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 0.25rem;">
                                    Load data to see recommended immediate actions
                                </p>
                            </div>
                        </li>
                    </ul>
                </div>

                <div class="action-category">
                    <h4 style="color: var(--warning);">
                        <span class="action-icon short-term">⚡</span>
                        Short-term Actions (30 days)
                    </h4>
                    <ul class="action-list" id="shortTermActions">
                        <li class="action-item">
                            <span class="action-icon short-term">📅</span>
                            <div style="flex: 1;">
                                <strong>No short-term actions identified</strong>
                                <p style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 0.25rem;">
                                    Actions will be generated based on data analysis
                                </p>
                            </div>
                        </li>
                    </ul>
                </div>

                <div class="action-category">
                    <h4 style="color: #2196F3;">
                        <span class="action-icon long-term">🎯</span>
                        Long-term Improvements
                    </h4>
                    <ul class="action-list" id="longTermActions">
                        <li class="action-item">
                            <span class="action-icon long-term">🔄</span>
                            <div style="flex: 1;">
                                <strong>No long-term improvements identified</strong>
                                <p style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 0.25rem;">
                                    Strategic improvements will be suggested based on trends
                                </p>
                            </div>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal for details -->
    <div id="detailModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modalTitle">Details</h3>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div id="modalBody">
                <!-- Content will be populated dynamically -->
            </div>
        </div>
    </div>

    <!-- Footer -->
    <footer class="footer">
        <p>
            Safety Analytics Platform v2.0 | Amazon WHS | 
            Developed by <a href="mailto:erwin.esener@amazon.com">Erwin Esener</a> | 
            © 2024 Amazon.com, Inc.
        </p>
    </footer>

    <script>
        // Global State Management
        const state = {
            injury: {
                rawData: [],
                filteredData: [],
                charts: {},
                currentPage: 1,
                timelinePage: 1
            },
            nearMiss: {
                rawData: [],
                filteredData: [],
                charts: {},
                currentPage: 1,
                timelinePage: 1,
                qualityCharts: {}
            },
            currentModule: 'overview',
            theme: 'light',
            itemsPerPage: 15
        };

        // Constants
        const SEVERITY_COLORS = {
            'A': '#B71C1C',
            'B': '#FF5722',
            'C': '#FFC107',
            'D': '#4CAF50',
            'Unknown': '#9E9E9E'
        };

        // Initialize Application
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Safety Analytics Platform - Amazon WHS');
            console.log('Developed by Erwin Esener');
            initializeCharts();
            setupEventListeners();
            createRiskMatrices();
            
            // Check for saved theme preference
            const savedTheme = localStorage.getItem('theme') || 'light';
            if (savedTheme === 'dark') {
                toggleTheme();
            }
        });

        // Theme Toggle
        function toggleTheme() {
            const body = document.body;
            const themeIcon = document.getElementById('themeIcon');
            const themeText = document.getElementById('themeText');
            
            if (body.getAttribute('data-theme') === 'dark') {
                body.removeAttribute('data-theme');
                themeIcon.textContent = '🌙';
                themeText.textContent = 'Dark Mode';
                state.theme = 'light';
            } else {
                body.setAttribute('data-theme', 'dark');
                themeIcon.textContent = '☀️';
                themeText.textContent = 'Light Mode';
                state.theme = 'dark';
            }
            
            localStorage.setItem('theme', state.theme);
            
            // Update charts for new theme
            updateAllCharts();
        }

        // Module Switching
        function switchModule(module) {
            // Update navigation
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.closest('.nav-tab').classList.add('active');
            
            // Hide all content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Show selected content
            document.getElementById(module).classList.add('active');
            state.currentModule = module;
            
            // Update specific modules
            if (module === 'combined') {
                updateCombinedAnalytics();
            } else if (module === 'actions') {
                updateActionItems();
            }
        }

        // Sub-view switching for Injury module
        function switchInjuryView(view) {
            document.querySelectorAll('#injury .sub-nav-item').forEach(item => {
                item.classList.remove('active');
            });
            event.target.classList.add('active');
            
            document.querySelectorAll('.injury-view').forEach(v => {
                v.classList.add('hidden');
            });
            
            document.getElementById('injury' + view.charAt(0).toUpperCase() + view.slice(1)).classList.remove('hidden');
            
            if (view === 'timeline') {
                updateInjuryTimeline();
            } else if (view === 'analytics') {
                updateInjuryAdvancedAnalytics();
            } else if (view === 'riskMatrix') {
                updateInjuryRiskMatrix();
            }
        }

        // Sub-view switching for Near Miss module
        function switchNearMissView(view) {
            document.querySelectorAll('#nearmiss .sub-nav-item').forEach(item => {
                item.classList.remove('active');
            });
            event.target.classList.add('active');
            
            document.querySelectorAll('.nearmiss-view').forEach(v => {
                v.classList.add('hidden');
            });
            
            document.getElementById('nearMiss' + view.charAt(0).toUpperCase() + view.slice(1)).classList.remove('hidden');
            
            if (view === 'timeline') {
                updateNearMissTimeline();
            } else if (view === 'analytics') {
                updateNearMissAdvancedAnalytics();
            } else if (view === 'riskMatrix') {
                updateNearMissRiskMatrix();
            } else if (view === 'quality') {
                updateNearMissQualityAnalysis();
            }
        }

        // File Handling
        function handleFileUpload(event, type) {
            const file = event.target.files[0];
            if (!file) return;
            
            showStatus(`Processing ${type} file...`, 'info');
            
            const reader = new FileReader();
            reader.onload = function(e) {
                parseCSV(e.target.result, type);
            };
            reader.onerror = function() {
                showStatus('Error reading file', 'error');
            };
            reader.readAsText(file);
        }

        // Drag and Drop
        function handleDrop(event, type) {
            event.preventDefault();
            event.stopPropagation();
            
            const uploadArea = event.target.closest('.upload-area');
            uploadArea.classList.remove('dragging');
            
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                if (file.type === 'text/csv' || file.name.endsWith('.csv')) {
                    // Create a fake event for the file input
                    const input = type === 'injury' ? 
                        document.getElementById('injuryFile') : 
                        document.getElementById('nearMissFile');
                    
                    const dataTransfer = new DataTransfer();
                    dataTransfer.items.add(file);
                    input.files = dataTransfer.files;
                    
                    handleFileUpload({ target: input }, type);
                } else {
                    showStatus('Please upload a CSV file', 'error');
                }
            }
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.stopPropagation();
            event.target.closest('.upload-area').classList.add('dragging');
        }

        function handleDragLeave(event) {
            event.preventDefault();
            event.stopPropagation();
            event.target.closest('.upload-area').classList.remove('dragging');
        }

        // CSV Parsing
        function parseCSV(csvText, type) {
            Papa.parse(csvText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    if (type === 'injury') {
                        state.injury.rawData = results.data;
                        processInjuryData();
                        populateInjuryFilters();
                        applyFilters('injury');
                        showStatus(`Loaded ${results.data.length} injury records successfully!`, 'success');
                    } else {
                        state.nearMiss.rawData = results.data;
                        processNearMissData();
                        populateNearMissFilters();
                        applyFilters('nearmiss');
                        showStatus(`Loaded ${results.data.length} near miss records successfully!`, 'success');
                    }
                    
                    updateOverview();
                },
                error: function(error) {
                    showStatus('Failed to parse CSV: ' + error.message, 'error');
                }
            });
        }

        // Data Processing - Injury
        function processInjuryData() {
            state.injury.rawData.forEach((row, index) => {
                // Parse dates
                if (row.incident_date) {
                    row.parsedDate = new Date(row.incident_date);
                }
                
                // Standardize severity
                row.severity = standardizeSeverity(row.severity || row.potential_severity);
                
                // Ensure numeric values
                row.recordable = parseInt(row.recordable) || 0;
                row.total_dafw_days = parseInt(row.total_dafw_days) || 0;
                row.total_rwa_days = parseInt(row.total_rwa_days) || 0;
                
                // Generate ID if needed
                if (!row.case_number) {
                    row.case_number = `CASE-${index + 1}`;
                }
                
                // Extract body part
                row.bodyPart = row.initial_info_principal_body_part || 
                              row.initial_info_detailed_body_part || 
                              'Unknown';
                
                // Extract OTR status
                if (row.initial_info_incident_on_the_road === true) {
                    row.otr = 'yes';
                } else if (row.initial_info_incident_on_the_road === false) {
                    row.otr = 'no';
                } else {
                    row.otr = row.initial_info_incident_on_the_road || 'no';
                    if (typeof row.otr === 'string') {
                        row.otr = row.otr.toLowerCase();
                    }
                    if (row.otr === '1' || row.otr === 'true' || row.otr === 'yes' || row.otr === 'y') {
                        row.otr = 'yes';
                    } else {
                        row.otr = 'no';
                    }
                }
                
                // Extract root cause
                row.rootCause = row.rca_primary_cause || 'Under Investigation';
                
                // Extract contributing factors
                row.contributingFactor = row.rca_contributing_factor_category || 'Unknown';
                
                // Process path
                row.processPath = row.initial_info_process_path || 'Unknown';
                
                // Extract incident URL (EHS system URL)
                row.incident_url = row.incident_url || null;
                
                // Extract description
                row.description = row.initial_info_incident_description || 'No description available';
                
                // Standardize likelihood
                row.standardized_likelihood = standardizeLikelihood(row.initial_risk_assessment_likeliness);
            });
        }

        // Data Processing - Near Miss
        function processNearMissData() {
            state.nearMiss.rawData.forEach((row, index) => {
                // Parse dates
                if (row.nearmiss_date) {
                    row.parsedDate = new Date(row.nearmiss_date);
                }
                
                // Use potential_severity
                row.severity = standardizeSeverity(row.potential_severity || row.severity);
                
                // Standardize likelihood
                row.standardized_likelihood = standardizeLikelihood(row.initial_risk_assessment_likeliness);
                
                // Calculate risk score if not present
                if (!row.risk || row.risk === '' || row.risk === 0) {
                    row.risk = calculateRiskScore(row);
                }
                
                // Generate ID if needed
                if (!row.incident_id) {
                    const date = row.parsedDate || new Date();
                    const site = (row.site && row.site.trim()) ? row.site.trim() : 'XX';
                    const year = date.getFullYear();
                    const month = String(date.getMonth() + 1).padStart(2, '0');
                    const seq = String(index + 1).padStart(3, '0');
                    row.incident_id = `NM-${site}-${year}${month}-${seq}`;
                }
                
                // Extract primary impact
                row.primaryImpact = row.initial_info_primary_impact || 'Unknown';
                
                // Extract location
                row.location = row.initial_info_location_event || 'Unknown';
                
                // Process path
                row.processPath = row.initial_info_process_path || 'Unknown';
                
                // Contributing factors
                row.contributingFactor = row.rca_contributing_factor_category || 'Unknown';
                
                // Extract incident URL
                row.incident_url = row.incident_url || null;
                
                // Extract description
                row.description = row.initial_info_incident_description || 'No description available';
                
                // Quality metrics
                row.descriptionLength = row.description.length;
                row.hasCompleteData = checkDataCompleteness(row);
            });
        }

        // Check data completeness for quality analysis
        function checkDataCompleteness(row) {
            const requiredFields = [
                'nearmiss_date',
                'site',
                'location',
                'processPath',
                'primaryImpact',
                'severity',
                'standardized_likelihood',
                'description'
            ];
            
            return requiredFields.every(field => 
                row[field] && 
                row[field] !== 'Unknown' && 
                row[field] !== 'No description available' &&
                (typeof row[field] === 'string' ? row[field].trim().length > 0 : true)
            );
        }

        // Standardize severity
        function standardizeSeverity(severity) {
            if (!severity) return 'Unknown';
            const severityStr = String(severity).toUpperCase().trim();
            
            if (['A', 'B', 'C', 'D'].includes(severityStr)) {
                return severityStr;
            }
            
            const lower = severityStr.toLowerCase();
            if (lower.includes('critical') || lower.includes('severe')) return 'A';
            if (lower.includes('high') || lower.includes('major')) return 'B';
            if (lower.includes('medium') || lower.includes('moderate')) return 'C';
            if (lower.includes('low') || lower.includes('minor')) return 'D';
            
            return 'Unknown';
        }

        // Standardize likelihood
        function standardizeLikelihood(likelihood) {
            if (!likelihood) return 'Possible';
            
            const likelihoodStr = String(likelihood).toLowerCase().trim();
            
            // Direct matches
            if (likelihoodStr.includes('rare')) return 'Rare';
            if (likelihoodStr.includes('unlikely')) return 'Unlikely';
            if (likelihoodStr.includes('possible')) return 'Possible';
            if (likelihoodStr.includes('likely') && !likelihoodStr.includes('unlikely')) {
                if (likelihoodStr.includes('almost') || likelihoodStr.includes('certain')) {
                    return 'Almost Certain';
                }
                return 'Likely';
            }
            if (likelihoodStr.includes('certain')) return 'Almost Certain';
            
            // Numeric values (1-5 scale)
            const numValue = parseInt(likelihoodStr);
            if (!isNaN(numValue)) {
                switch(numValue) {
                    case 1: return 'Rare';
                    case 2: return 'Unlikely';
                    case 3: return 'Possible';
                    case 4: return 'Likely';
                    case 5: return 'Almost Certain';
                }
            }
            
            return 'Possible'; // Default
        }

        // Calculate risk score
        function calculateRiskScore(row) {
            const severityMap = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'Unknown': 1 };
            const likelihoodMap = { 
                'Rare': 1, 
                'Unlikely': 2, 
                'Possible': 3, 
                'Likely': 4, 
                'Almost Certain': 5 
            };
            
            const severity = severityMap[row.severity] || 1;
            const likelihood = likelihoodMap[row.standardized_likelihood] || 3;
            
            return ((severity * likelihood) / 5 * 2).toFixed(1); // Scale to 0-10
        }

        // Populate Filters
        function populateInjuryFilters() {
            // Sites
            const sites = [...new Set(state.injury.rawData.map(r => r.site).filter(Boolean))];
            const siteFilter = document.getElementById('injurySiteFilter');
            siteFilter.innerHTML = '<option value="">All Sites</option>';
            sites.sort().forEach(site => {
                siteFilter.innerHTML += `<option value="${site}">${site}</option>`;
            });
            
            // Body Parts
            const bodyParts = [...new Set(state.injury.rawData.map(r => r.bodyPart).filter(Boolean))];
            const bodyPartFilter = document.getElementById('injuryBodyPartFilter');
            bodyPartFilter.innerHTML = '<option value="">All Body Parts</option>';
            bodyParts.sort().slice(0, 20).forEach(part => {
                const truncated = part.length > 30 ? part.substring(0, 30) + '...' : part;
                bodyPartFilter.innerHTML += `<option value="${part}">${truncated}</option>`;
            });
            
            // Root Causes
            const rootCauses = [...new Set(state.injury.rawData.map(r => r.rootCause).filter(Boolean))];
            const rootCauseFilter = document.getElementById('injuryRootCauseFilter');
            rootCauseFilter.innerHTML = '<option value="">All Causes</option>';
            rootCauses.sort().forEach(cause => {
                const truncated = cause.length > 30 ? cause.substring(0, 30) + '...' : cause;
                rootCauseFilter.innerHTML += `<option value="${cause}">${truncated}</option>`;
            });
        }

        function populateNearMissFilters() {
            // Sites
            const sites = [...new Set(state.nearMiss.rawData.map(r => r.site).filter(Boolean))];
            const siteFilter = document.getElementById('nearMissSiteFilter');
            siteFilter.innerHTML = '<option value="">All Sites</option>';
            sites.sort().forEach(site => {
                siteFilter.innerHTML += `<option value="${site}">${site}</option>`;
            });
            
            // Primary Impacts
            const impacts = [...new Set(state.nearMiss.rawData.map(r => r.primaryImpact).filter(Boolean))];
            const impactFilter = document.getElementById('nearMissPrimaryImpactFilter');
            impactFilter.innerHTML = '<option value="">All Impacts</option>';
            impacts.sort().forEach(impact => {
                impactFilter.innerHTML += `<option value="${impact}">${impact}</option>`;
            });
            
            // Locations
            const locations = [...new Set(state.nearMiss.rawData.map(r => r.location).filter(Boolean))];
            const locationFilter = document.getElementById('nearMissLocationFilter');
            locationFilter.innerHTML = '<option value="">All Locations</option>';
            locations.sort().slice(0, 20).forEach(location => {
                const truncated = location.length > 30 ? location.substring(0, 30) + '...' : location;
                locationFilter.innerHTML += `<option value="${location}">${truncated}</option>`;
            });
            
            // Process Paths
            const processes = [...new Set(state.nearMiss.rawData.map(r => r.processPath).filter(Boolean))];
            const processFilter = document.getElementById('nearMissProcessFilter');
            processFilter.innerHTML = '<option value="">All Processes</option>';
            processes.sort().forEach(process => {
                processFilter.innerHTML += `<option value="${process}">${process}</option>`;
            });
        }

        // Apply Filters
        function applyFilters(type) {
            if (type === 'injury') {
                const siteFilter = document.getElementById('injurySiteFilter').value;
                const severityFilter = document.getElementById('injurySeverityFilter').value;
                const recordableFilter = document.getElementById('injuryRecordableFilter').value;
                const otrFilter = document.getElementById('injuryOTRFilter').value;
                const bodyPartFilter = document.getElementById('injuryBodyPartFilter').value;
                const rootCauseFilter = document.getElementById('injuryRootCauseFilter').value;
                const dateFrom = document.getElementById('injuryDateFrom').value;
                const dateTo = document.getElementById('injuryDateTo').value;
                
                state.injury.filteredData = state.injury.rawData.filter(row => {
                    if (siteFilter && row.site !== siteFilter) return false;
                    if (severityFilter && row.severity !== severityFilter) return false;
                    if (recordableFilter !== '' && row.recordable != recordableFilter) return false;
                    if (otrFilter && row.otr !== otrFilter) return false;
                    if (bodyPartFilter && row.bodyPart !== bodyPartFilter) return false;
                    if (rootCauseFilter && row.rootCause !== rootCauseFilter) return false;
                    
                    if (dateFrom || dateTo) {
                        const rowDate = row.parsedDate;
                        if (!rowDate || isNaN(rowDate)) return false;
                        if (dateFrom && rowDate < new Date(dateFrom)) return false;
                        if (dateTo && rowDate > new Date(dateTo)) return false;
                    }
                    
                    return true;
                });
                
                state.injury.currentPage = 1;
                updateInjuryDashboard();
                updateInjuryTable();
                updateInjuryCharts();
            } else {
                const siteFilter = document.getElementById('nearMissSiteFilter').value;
                const severityFilter = document.getElementById('nearMissSeverityFilter').value;
                const impactFilter = document.getElementById('nearMissPrimaryImpactFilter').value;
                const locationFilter = document.getElementById('nearMissLocationFilter').value;
                const processFilter = document.getElementById('nearMissProcessFilter').value;
                const likelihoodFilter = document.getElementById('nearMissLikelihoodFilter').value;
                const dateFrom = document.getElementById('nearMissDateFrom').value;
                const dateTo = document.getElementById('nearMissDateTo').value;
                
                state.nearMiss.filteredData = state.nearMiss.rawData.filter(row => {
                    if (siteFilter && row.site !== siteFilter) return false;
                    if (severityFilter && row.severity !== severityFilter) return false;
                    if (impactFilter && row.primaryImpact !== impactFilter) return false;
                    if (locationFilter && row.location !== locationFilter) return false;
                    if (processFilter && row.processPath !== processFilter) return false;
                    if (likelihoodFilter && row.standardized_likelihood !== likelihoodFilter) return false;
                    
                    if (dateFrom || dateTo) {
                        const rowDate = row.parsedDate;
                        if (!rowDate || isNaN(rowDate)) return false;
                        if (dateFrom && rowDate < new Date(dateFrom)) return false;
                        if (dateTo && rowDate > new Date(dateTo)) return false;
                    }
                    
                    return true;
                });
                
                state.nearMiss.currentPage = 1;
                updateNearMissDashboard();
                updateNearMissTable();
                updateNearMissCharts();
            }
            
            updateOverview();
            updateKPIs();
        }

        // Update KPIs
        function updateKPIs() {
            if (state.injury.rawData.length === 0 && state.nearMiss.rawData.length === 0) return;
            
            // Calculate rates (per 200,000 hours - standard OSHA calculation)
            const hoursWorked = 200000; // Standard baseline
            
            // TRIR (Total Recordable Incident Rate)
            const recordableCount = state.injury.filteredData.filter(r => r.recordable === 1).length;
            const trir = ((recordableCount / hoursWorked) * 200000).toFixed(2);
            document.getElementById('kpiTRIR').textContent = trir;
            
            // LTIR (Lost Time Incident Rate)
            const lostTimeCount = state.injury.filteredData.filter(r => r.total_dafw_days > 0).length;
            const ltir = ((lostTimeCount / hoursWorked) * 200000).toFixed(2);
            document.getElementById('kpiLTIR').textContent = ltir;
            
            // DAFWR (Days Away From Work Rate)
            const totalDaysLost = state.injury.filteredData.reduce((sum, r) => sum + (r.total_dafw_days || 0), 0);
            const dafwr = ((totalDaysLost / hoursWorked) * 200000).toFixed(2);
            document.getElementById('kpiDAFWR').textContent = dafwr;
            
            // NMFR (Near Miss Frequency Rate)
            const nearMissCount = state.nearMiss.filteredData.length;
            const nmfr = ((nearMissCount / hoursWorked) * 200000).toFixed(2);
            document.getElementById('kpiNMFR').textContent = nmfr;
        }

        // Update Dashboards
        function updateInjuryDashboard() {
            const data = state.injury.filteredData;
            
            document.getElementById('injuryTotal').textContent = data.length;
            document.getElementById('injuryRecordable').textContent = 
                data.filter(r => r.recordable === 1).length;
            document.getElementById('injuryLostTime').textContent = 
                data.filter(r => r.total_dafw_days > 0).length;
            document.getElementById('injuryDaysLost').textContent = 
                data.reduce((sum, r) => sum + (r.total_dafw_days || 0), 0);
            document.getElementById('injuryOTR').textContent = 
                data.filter(r => r.otr === 'yes').length;
            
            // Calculate recordable rate
            const recordableCount = data.filter(r => r.recordable === 1).length;
            const recordableRate = data.length > 0 ? 
                ((recordableCount / data.length) * 100).toFixed(1) : '0.0';
            document.getElementById('injuryRecordableRate').textContent = recordableRate + '%';
        }

        function updateNearMissDashboard() {
            const data = state.nearMiss.filteredData;
            
            document.getElementById('nearMissTotal').textContent = data.length;
            
            const risks = data.map(r => parseFloat(r.risk)).filter(r => !isNaN(r));
            const avgRisk = risks.length > 0 ? 
                (risks.reduce((a, b) => a + b, 0) / risks.length).toFixed(1) : '0.0';
            document.getElementById('nearMissRisk').textContent = avgRisk;
            
            document.getElementById('nearMissHigh').textContent = 
                data.filter(r => r.severity === 'A' || r.severity === 'B').length;
            
            // Calculate repeat locations
            const locationCounts = {};
            data.forEach(row => {
                const location = row.location || 'Unknown';
                locationCounts[location] = (locationCounts[location] || 0) + 1;
            });
            const repeatLocations = Object.values(locationCounts).filter(count => count >= 2).length;
            document.getElementById('nearMissRepeat').textContent = repeatLocations;
            
            // Actionable items (high risk)
            const actionableCount = data.filter(r => parseFloat(r.risk) >= 7).length;
            document.getElementById('nearMissActionable').textContent = actionableCount;
            
            // Frequency rate
            const frequencyRate = data.length > 0 ? 
                (data.length / 30).toFixed(1) : '0.0'; // Per month
            document.getElementById('nearMissFrequency').textContent = frequencyRate;
        }

        // Update Tables with Pagination
        function updateInjuryTable() {
            const tbody = document.getElementById('injuryTableBody');
            const data = state.injury.filteredData;
            const currentPage = state.injury.currentPage;
            const startIndex = (currentPage - 1) * state.itemsPerPage;
            const endIndex = Math.min(startIndex + state.itemsPerPage, data.length);
            const pageData = data.slice(startIndex, endIndex);
            
            if (pageData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="11" style="text-align: center; padding: 3rem;">No data matches the current filters.</td></tr>';
                updatePaginationInfo('injury', 0, 0);
                return;
            }
            
            tbody.innerHTML = pageData.map(row => `
                <tr>
                    <td>${row.case_number || 'N/A'}</td>
                    <td>${row.incident_date || 'N/A'}</td>
                    <td>${row.site || 'N/A'}</td>
                    <td title="${row.bodyPart || ''}">${(row.bodyPart || 'N/A').substring(0, 20)}${row.bodyPart?.length > 20 ? '...' : ''}</td>
                    <td>${row.type || 'N/A'}</td>
                    <td><span class="badge badge-${getSeverityClass(row.severity)}">${row.severity}</span></td>
                    <td><span class="badge badge-${row.recordable === 1 ? 'danger' : 'success'}">${row.recordable === 1 ? 'Yes' : 'No'}</span></td>
                    <td><span class="badge badge-${row.otr === 'yes' ? 'warning' : 'info'}">${row.otr === 'yes' ? 'Yes' : 'No'}</span></td>
                    <td>${row.total_dafw_days || 0}</td>
                    <td title="${row.rootCause || ''}">${(row.rootCause || 'N/A').substring(0, 20)}${row.rootCause?.length > 20 ? '...' : ''}</td>
                    <td>
                        <button class="btn btn-sm btn-outline" onclick="viewDetails('injury', '${row.case_number}')">View</button>
                        ${row.incident_url ? `<a href="${row.incident_url}" target="_blank" class="austin-link" title="View in EHS System">📋</a>` : ''}
                    </td>
                </tr>
            `).join('');
            
            updatePaginationInfo('injury', currentPage, Math.ceil(data.length / state.itemsPerPage));
        }

        function updateNearMissTable() {
            const tbody = document.getElementById('nearMissTableBody');
            const data = state.nearMiss.filteredData;
            const currentPage = state.nearMiss.currentPage;
            const startIndex = (currentPage - 1) * state.itemsPerPage;
            const endIndex = Math.min(startIndex + state.itemsPerPage, data.length);
            const pageData = data.slice(startIndex, endIndex);
            
            if (pageData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="10" style="text-align: center; padding: 3rem;">No data matches the current filters.</td></tr>';
                updatePaginationInfo('nearmiss', 0, 0);
                return;
            }
            
            tbody.innerHTML = pageData.map(row => `
                <tr>
                    <td>${row.incident_id || 'N/A'}</td>
                    <td>${row.nearmiss_date || 'N/A'}</td>
                    <td>${row.site || 'N/A'}</td>
                    <td title="${row.location || ''}">${(row.location || 'N/A').substring(0, 25)}${row.location?.length > 25 ? '...' : ''}</td>
                    <td title="${row.processPath || ''}">${(row.processPath || 'N/A').substring(0, 20)}${row.processPath?.length > 20 ? '...' : ''}</td>
                    <td title="${row.primaryImpact || ''}">${(row.primaryImpact || 'N/A').substring(0, 20)}${row.primaryImpact?.length > 20 ? '...' : ''}</td>
                    <td><span class="badge badge-${getSeverityClass(row.severity)}">${row.severity}</span></td>
                    <td><span class="badge badge-info">${row.standardized_likelihood || 'N/A'}</span></td>
                    <td><span class="badge badge-${getRiskClass(row.risk)}">${row.risk || 'N/A'}</span></td>
                    <td>
                        <button class="btn btn-sm btn-outline" onclick="viewDetails('nearmiss', '${row.incident_id}')">View</button>
                        ${row.incident_url ? `<a href="${row.incident_url}" target="_blank" class="austin-link" title="View in EHS System">📋</a>` : ''}
                    </td>
                </tr>
            `).join('');
            
            updatePaginationInfo('nearmiss', currentPage, Math.ceil(data.length / state.itemsPerPage));
        }

        // Pagination
        function changePage(type, direction) {
            const data = type === 'injury' ? state.injury.filteredData : state.nearMiss.filteredData;
            const totalPages = Math.ceil(data.length / state.itemsPerPage);
            
            if (type === 'injury') {
                state.injury.currentPage += direction;
                if (state.injury.currentPage < 1) state.injury.currentPage = 1;
                if (state.injury.currentPage > totalPages) state.injury.currentPage = totalPages;
                updateInjuryTable();
            } else {
                state.nearMiss.currentPage += direction;
                if (state.nearMiss.currentPage < 1) state.nearMiss.currentPage = 1;
                if (state.nearMiss.currentPage > totalPages) state.nearMiss.currentPage = totalPages;
                updateNearMissTable();
            }
        }

        function updatePaginationInfo(type, currentPage, totalPages) {
            const pageInfo = document.getElementById(`${type}PageInfo`);
            const prevBtn = document.getElementById(`${type}PrevBtn`);
            const nextBtn = document.getElementById(`${type}NextBtn`);
            
            if (pageInfo) pageInfo.textContent = `Page ${currentPage} of ${totalPages || 1}`;
            if (prevBtn) prevBtn.disabled = currentPage <= 1;
            if (nextBtn) nextBtn.disabled = currentPage >= totalPages;
        }

        // Get severity class for badges
        function getSeverityClass(severity) {
            switch(severity) {
                case 'A': return 'critical';
                case 'B': return 'danger';
                case 'C': return 'warning';
                case 'D': return 'success';
                default: return 'secondary';
            }
        }

        function getRiskClass(risk) {
            const riskValue = parseFloat(risk);
            if (riskValue >= 8) return 'critical';
            if (riskValue >= 6) return 'danger';
            if (riskValue >= 4) return 'warning';
            if (riskValue >= 2) return 'success';
            return 'info';
        }

        // Initialize Charts
        function initializeCharts() {
            // Injury Charts
            for (let i = 1; i <= 4; i++) {
                const ctx = document.getElementById(`injuryChart${i}`)?.getContext('2d');
                if (ctx) {
                    state.injury.charts[`chart${i}`] = new Chart(ctx, {
                        type: 'doughnut',
                        data: { labels: [], datasets: [] },
                        options: getChartOptions('doughnut')
                    });
                }
            }
            
            // Near Miss Charts
            for (let i = 1; i <= 4; i++) {
                const ctx = document.getElementById(`nearMissChart${i}`)?.getContext('2d');
                if (ctx) {
                    state.nearMiss.charts[`chart${i}`] = new Chart(ctx, {
                        type: 'doughnut',
                        data: { labels: [], datasets: [] },
                        options: getChartOptions('doughnut')
                    });
                }
            }
            
            // Initialize advanced analytics charts
            initializeAdvancedCharts();
            
            // Initialize overview charts
            initializeOverviewCharts();
            
            // Initialize combined charts
            initializeCombinedCharts();
            
            // Initialize quality analysis charts
            initializeQualityCharts();
        }

        function initializeAdvancedCharts() {
            // Injury Advanced Analytics
            const injuryAdvancedCharts = [
                'injuryRecordableRateTrendChart',
                'injuryBodyPartHeatMapChart',
                'injuryRootCauseBySiteChart',
                'injuryDAFWDistributionChart'
            ];
            
            injuryAdvancedCharts.forEach(chartId => {
                const ctx = document.getElementById(chartId)?.getContext('2d');
                if (ctx) {
                    state.injury.charts[chartId] = new Chart(ctx, {
                        type: 'line',
                        data: { labels: [], datasets: [] },
                        options: getChartOptions('line')
                    });
                }
            });
            
            // Near Miss Advanced Analytics
            const nearMissAdvancedCharts = [
                'nearMissRiskTrendChart',
                'nearMissImpactAnalysisChart',
                'nearMissLocationRiskChart',
                'nearMissProcessRiskChart'
            ];
            
            nearMissAdvancedCharts.forEach(chartId => {
                const ctx = document.getElementById(chartId)?.getContext('2d');
                if (ctx) {
                    state.nearMiss.charts[chartId] = new Chart(ctx, {
                        type: 'line',
                        data: { labels: [], datasets: [] },
                        options: getChartOptions('line')
                    });
                }
            });
        }

        function initializeOverviewCharts() {
            const overviewTrendCtx = document.getElementById('overviewTrendChart')?.getContext('2d');
            if (overviewTrendCtx) {
                new Chart(overviewTrendCtx, {
                    type: 'line',
                    data: { labels: [], datasets: [] },
                    options: getChartOptions('line')
                });
            }
            
            const overviewSiteCtx = document.getElementById('overviewSiteChart')?.getContext('2d');
            if (overviewSiteCtx) {
                new Chart(overviewSiteCtx, {
                    type: 'bar',
                    data: { labels: [], datasets: [] },
                    options: getChartOptions('bar')
                });
            }
        }

        function initializeCombinedCharts() {
            const combinedChartIds = [
                'combinedTrendChart',
                'combinedSiteChart',
                'combinedSeverityChart',
                'combinedPreventionChart'
            ];
            
            combinedChartIds.forEach(chartId => {
                const ctx = document.getElementById(chartId)?.getContext('2d');
                if (ctx) {
                    new Chart(ctx, {
                        type: 'line',
                        data: { labels: [], datasets: [] },
                        options: getChartOptions('line')
                    });
                }
            });
        }

        function initializeQualityCharts() {
            const qualityChartIds = [
                'descLengthChart',
                'qualityBySiteChart',
                'commonPhrasesChart',
                'qualityTrendChart'
            ];
            
            qualityChartIds.forEach(chartId => {
                const ctx = document.getElementById(chartId)?.getContext('2d');
                if (ctx) {
                    state.nearMiss.qualityCharts[chartId] = new Chart(ctx, {
                        type: chartId === 'descLengthChart' ? 'bar' : 'bar',
                        data: { labels: [], datasets: [] },
                        options: getChartOptions('bar')
                    });
                }
            });
        }

        // Get chart options based on type
        function getChartOptions(type) {
            const isDark = state.theme === 'dark';
            const textColor = isDark ? '#ffffff' : '#212121';
            const gridColor = isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
            
            const baseOptions = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: type === 'doughnut' || type === 'pie',
                        position: 'bottom',
                        labels: {
                            color: textColor,
                            padding: 20,
                            font: {
                                size: 12
                            }
                        }
                    },
                    tooltip: {
                        backgroundColor: isDark ? 'rgba(0, 0, 0, 0.8)' : 'rgba(255, 255, 255, 0.9)',
                        titleColor: isDark ? '#ffffff' : '#212121',
                        bodyColor: isDark ? '#ffffff' : '#212121',
                        borderColor: isDark ? 'rgba(255, 255, 255, 0.3)' : 'rgba(0, 0, 0, 0.3)',
                        borderWidth: 1,
                        padding: 12,
                        cornerRadius: 8
                    }
                }
            };
            
            if (type === 'line' || type === 'bar') {
                baseOptions.scales = {
                    x: {
                        ticks: {
                            color: textColor
                        },
                        grid: {
                            color: gridColor
                        }
                    },
                    y: {
                        ticks: {
                            color: textColor
                        },
                        grid: {
                            color: gridColor
                        },
                        beginAtZero: true
                    }
                };
            }
            
            return baseOptions;
        }

        // Update Charts
        function updateInjuryCharts() {
            updateInjuryChart(1, document.querySelector('#injuryChart1').parentElement.parentElement.querySelector('select').value || 'severity');
            updateInjuryChart(2, document.querySelector('#injuryChart2').parentElement.parentElement.querySelector('select').value || 'trend');
            updateInjuryChart(3, document.querySelector('#injuryChart3').parentElement.parentElement.querySelector('select').value || 'site');
            updateInjuryChart(4, document.querySelector('#injuryChart4').parentElement.parentElement.querySelector('select').value || 'impactType');
        }

        function updateNearMissCharts() {
            updateNearMissChart(1, document.querySelector('#nearMissChart1').parentElement.parentElement.querySelector('select').value || 'severity');
            updateNearMissChart(2, document.querySelector('#nearMissChart2').parentElement.parentElement.querySelector('select').value || 'process');
            updateNearMissChart(3, document.querySelector('#nearMissChart3').parentElement.parentElement.querySelector('select').value || 'impactBySeverity');
            updateNearMissChart(4, document.querySelector('#nearMissChart4').parentElement.parentElement.querySelector('select').value || 'riskMatrix');
        }

        function updateInjuryChart(chartNum, type) {
            const chart = state.injury.charts[`chart${chartNum}`];
            if (!chart || state.injury.filteredData.length === 0) return;
            
            const data = state.injury.filteredData;
            
            switch(type) {
                case 'severity':
                    updateSeverityChart(chart, data);
                    break;
                case 'bodyPart':
                    updateBodyPartChart(chart, data);
                    break;
                case 'rootCause':
                    updateRootCauseChart(chart, data);
                    break;
                case 'processPath':
                    updateProcessPathChart(chart, data);
                    break;
                case 'contributingFactors':
                    updateContributingFactorsChart(chart, data);
                    break;
                case 'otrAnalysis':
                    updateOTRAnalysisChart(chart, data);
                    break;
                case 'trend':
                    updateTrendChart(chart, data, 'injury');
                    break;
                case 'recordableTrend':
                    updateRecordableTrendChart(chart, data);
                    break;
                case 'lostTimeTrend':
                    updateLostTimeTrendChart(chart, data);
                    break;
                case 'dafwAnalysis':
                    updateDAFWAnalysisChart(chart, data);
                    break;
                case 'site':
                    updateSiteChart(chart, data);
                    break;
                case 'recordableRate':
                    updateRecordableRateChart(chart, data);
                    break;
                case 'severityBySite':
                    updateSeverityBySiteChart(chart, data);
                    break;
                case 'impactType':
                    updateImpactTypeChart(chart, data);
                    break;
                case 'bodyPartHeatmap':
                    updateBodyPartHeatmapChart(chart, data);
                    break;
                case 'riskTrend':
                    updateRiskTrendChart(chart, data);
                    break;
            }
        }

        function updateNearMissChart(chartNum, type) {
            const chart = state.nearMiss.charts[`chart${chartNum}`];
            if (!chart || state.nearMiss.filteredData.length === 0) return;
            
            const data = state.nearMiss.filteredData;
            
            switch(type) {
                case 'severity':
                    updateSeverityChart(chart, data);
                    break;
                case 'location':
                    updateLocationChart(chart, data);
                    break;
                case 'impact':
                    updateImpactChart(chart, data);
                    break;
                case 'likelihood':
                    updateLikelihoodChart(chart, data);
                    break;
                case 'process':
                    updateProcessChart(chart, data);
                    break;
                case 'trend':
                    updateTrendChart(chart, data, 'nearmiss');
                    break;
                case 'site':
                    updateSiteChart(chart, data);
                    break;
                case 'riskTrend':
                    updateRiskTrendChart(chart, data);
                    break;
                case 'impactBySeverity':
                    updateImpactBySeverityChart(chart, data);
                    break;
                case 'locationHeatmap':
                    updateLocationHeatmapChart(chart, data);
                    break;
                case 'contributingFactors':
                    updateContributingFactorsChart(chart, data);
                    break;
                case 'riskMatrix':
                    updateRiskMatrixChart(chart, data);
                    break;
                case 'highRiskAreas':
                    updateHighRiskAreasChart(chart, data);
                    break;
                case 'preventionOpportunities':
                    updatePreventionOpportunitiesChart(chart, data);
                    break;
            }
        }

        // Chart Update Functions
        function updateSeverityChart(chart, data) {
            const severityCounts = {
                'A': data.filter(r => r.severity === 'A').length,
                'B': data.filter(r => r.severity === 'B').length,
                'C': data.filter(r => r.severity === 'C').length,
                'D': data.filter(r => r.severity === 'D').length
            };
            
            const nonZero = Object.entries(severityCounts).filter(([_, count]) => count > 0);
            
            chart.config.type = 'doughnut';
            chart.data = {
                labels: nonZero.map(([severity]) => `Severity ${severity}`),
                datasets: [{
                    data: nonZero.map(([, count]) => count),
                    backgroundColor: nonZero.map(([severity]) => SEVERITY_COLORS[severity])
                }]
            };
            chart.options = getChartOptions('doughnut');
            chart.update();
        }

        function updateBodyPartChart(chart, data) {
            const bodyPartCounts = {};
            data.forEach(row => {
                const part = row.bodyPart || 'Unknown';
                bodyPartCounts[part] = (bodyPartCounts[part] || 0) + 1;
            });
            
            const topParts = Object.entries(bodyPartCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 8);
            
            chart.config.type = 'bar';
            chart.data = {
                labels: topParts.map(([part]) => part.substring(0, 20) + (part.length > 20 ? '...' : '')),
                datasets: [{
                    data: topParts.map(([, count]) => count),
                    backgroundColor: 'rgba(76, 175, 80, 0.8)',
                    borderColor: 'rgba(76, 175, 80, 1)',
                    borderWidth: 1,
                    label: 'Incidents'
                }]
            };
            chart.options = getChartOptions('bar');
            chart.options.indexAxis = 'y';
            chart.update();
        }

        function updateRootCauseChart(chart, data) {
            const causeCounts = {};
            data.forEach(row => {
                const cause = row.rootCause || 'Unknown';
                causeCounts[cause] = (causeCounts[cause] || 0) + 1;
            });
            
            const topCauses = Object.entries(causeCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 8);
            
            chart.config.type = 'bar';
            chart.data = {
                labels: topCauses.map(([cause]) => cause.substring(0, 25) + (cause.length > 25 ? '...' : '')),
                datasets: [{
                    data: topCauses.map(([, count]) => count),
                    backgroundColor: 'rgba(35, 47, 62, 0.8)',
                    borderColor: 'rgba(35, 47, 62, 1)',
                    borderWidth: 1,
                    label: 'Cases'
                }]
            };
            chart.options = getChartOptions('bar');
            chart.options.indexAxis = 'y';
            chart.update();
        }

        function updateProcessPathChart(chart, data) {
            const pathCounts = {};
            data.forEach(row => {
                const path = row.processPath || row.initial_info_process_path || 'Unknown';
                pathCounts[path] = (pathCounts[path] || 0) + 1;
            });
            
            const topPaths = Object.entries(pathCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 8);
            
            chart.config.type = 'bar';
            chart.data = {
                labels: topPaths.map(([path]) => path),
                datasets: [{
                    data: topPaths.map(([, count]) => count),
                    backgroundColor: 'rgba(55, 71, 90, 0.8)',
                    borderColor: 'rgba(55, 71, 90, 1)',
                    borderWidth: 1,
                    label: 'Cases'
                }]
            };
            chart.options = getChartOptions('bar');
            chart.update();
        }

        function updateContributingFactorsChart(chart, data) {
            const factorCounts = {};
            data.forEach(row => {
                const factor = row.contributingFactor || row.rca_contributing_factor_category || 'Unknown';
                factorCounts[factor] = (factorCounts[factor] || 0) + 1;
            });
            
            const topFactors = Object.entries(factorCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 6);
            
            chart.config.type = 'doughnut';
            chart.data = {
                labels: topFactors.map(([factor]) => factor),
                datasets: [{
                    data: topFactors.map(([, count]) => count),
                    backgroundColor: [
                        'rgba(76, 175, 80, 0.8)',
                        'rgba(35, 47, 62, 0.8)',
                        'rgba(55, 71, 90, 0.8)',
                        'rgba(255, 87, 34, 0.8)',
                        'rgba(76, 175, 80, 0.8)',
                        'rgba(33, 150, 243, 0.8)'
                    ],
                    label: 'Cases'
                }]
            };
            chart.options = getChartOptions('doughnut');
            chart.update();
        }

        function updateOTRAnalysisChart(chart, data) {
            const otrCounts = {
                'On The Road': data.filter(r => r.otr === 'yes').length,
                'Not On The Road': data.filter(r => r.otr === 'no').length
            };
            
            chart.config.type = 'doughnut';
            chart.data = {
                labels: Object.keys(otrCounts),
                datasets: [{
                    data: Object.values(otrCounts),
                    backgroundColor: ['rgba(255, 87, 34, 0.8)', 'rgba(76, 175, 80, 0.8)'],
                    label: 'Cases'
                }]
            };
            chart.options = getChartOptions('doughnut');
            chart.update();
        }

        function updateTrendChart(chart, data, type) {
            const monthlyData = {};
            data.forEach(row => {
                if (row.parsedDate && !isNaN(row.parsedDate)) {
                    const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
                    monthlyData[monthKey] = (monthlyData[monthKey] || 0) + 1;
                }
            });
            
            const sortedMonths = Object.keys(monthlyData).sort();
            const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            
            chart.config.type = 'line';
            chart.data = {
                labels: sortedMonths.map(m => {
                    const [year, month] = m.split('-');
                    return `${monthNames[parseInt(month)-1]} ${year}`;
                }),
                datasets: [{
                    label: type === 'injury' ? 'Injuries' : 'Near Misses',
                    data: sortedMonths.map(m => monthlyData[m]),
                    borderColor: 'rgba(76, 175, 80, 1)',
                    backgroundColor: 'rgba(76, 175, 80, 0.1)',
                    tension: 0.3
                }]
            };
            chart.options = getChartOptions('line');
            chart.update();
        }

        function updateRecordableTrendChart(chart, data) {
            const monthlyData = {};
            data.forEach(row => {
                if (row.parsedDate && !isNaN(row.parsedDate) && row.recordable === 1) {
                    const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
                    monthlyData[monthKey] = (monthlyData[monthKey] || 0) + 1;
                }
            });
            
            const sortedMonths = Object.keys(monthlyData).sort();
            const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            
            chart.config.type = 'line';
            chart.data = {
                labels: sortedMonths.map(m => {
                    const [year, month] = m.split('-');
                    return `${monthNames[parseInt(month)-1]} ${year}`;
                }),
                datasets: [{
                    label: 'Recordable Cases',
                    data: sortedMonths.map(m => monthlyData[m] || 0),
                    borderColor: 'rgba(255, 87, 34, 1)',
                    backgroundColor: 'rgba(255, 87, 34, 0.1)',
                    tension: 0.3
                }]
            };
            chart.options = getChartOptions('line');
            chart.update();
        }

        function updateLostTimeTrendChart(chart, data) {
            const monthlyData = {};
            data.forEach(row => {
                if (row.parsedDate && !isNaN(row.parsedDate) && row.total_dafw_days > 0) {
                    const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
                    monthlyData[monthKey] = (monthlyData[monthKey] || 0) + 1;
                }
            });
            
            const sortedMonths = Object.keys(monthlyData).sort();
            const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            
            chart.config.type = 'line';
            chart.data = {
                labels: sortedMonths.map(m => {
                    const [year, month] = m.split('-');
                    return `${monthNames[parseInt(month)-1]} ${year}`;
                }),
                datasets: [{
                    label: 'Lost Time Cases',
                    data: sortedMonths.map(m => monthlyData[m] || 0),
                    borderColor: 'rgba(183, 28, 28, 1)',
                    backgroundColor: 'rgba(183, 28, 28, 0.1)',
                    tension: 0.3
                }]
            };
            chart.options = getChartOptions('line');
            chart.update();
        }

        function updateDAFWAnalysisChart(chart, data) {
            const dafwRanges = {
                '0 Days': 0,
                '1-3 Days': 0,
                '4-7 Days': 0,
                '8-14 Days': 0,
                '15-30 Days': 0,
                '30+ Days': 0
            };
            
            data.forEach(row => {
                const days = row.total_dafw_days || 0;
                if (days === 0) dafwRanges['0 Days']++;
                else if (days <= 3) dafwRanges['1-3 Days']++;
                else if (days <= 7) dafwRanges['4-7 Days']++;
                else if (days <= 14) dafwRanges['8-14 Days']++;
                else if (days <= 30) dafwRanges['15-30 Days']++;
                else dafwRanges['30+ Days']++;
            });
            
            chart.config.type = 'doughnut';
            chart.data = {
                labels: Object.keys(dafwRanges),
                datasets: [{
                    data: Object.values(dafwRanges),
                    backgroundColor: [
                        'rgba(76, 175, 80, 0.8)',
                        'rgba(255, 193, 7, 0.8)',
                        'rgba(255, 153, 0, 0.8)',
                        'rgba(255, 87, 34, 0.8)',
                        'rgba(183, 28, 28, 0.8)',
                        'rgba(55, 71, 90, 0.8)'
                    ],
                    label: 'Cases'
                }]
            };
            chart.options = getChartOptions('doughnut');
            chart.update();
        }

        function updateSiteChart(chart, data) {
            const siteCounts = {};
            data.forEach(row => {
                const site = row.site || 'Unknown';
                siteCounts[site] = (siteCounts[site] || 0) + 1;
            });
            
            const sites = Object.entries(siteCounts)
                .sort((a, b) => b[1] - a[1]);
            
            chart.config.type = 'bar';
            chart.data = {
                labels: sites.map(([site]) => site),
                datasets: [{
                    data: sites.map(([, count]) => count),
                    backgroundColor: sites.map((_, i) => 
                        i % 2 === 0 ? 'rgba(76, 175, 80, 0.8)' : 'rgba(35, 47, 62, 0.8)'
                    ),
                    borderWidth: 1,
                    label: 'Incidents'
                }]
            };
            chart.options = getChartOptions('bar');
            chart.update();
        }

        function updateRecordableRateChart(chart, data) {
            const siteData = {};
            data.forEach(row => {
                const site = row.site || 'Unknown';
                if (!siteData[site]) {
                    siteData[site] = { total: 0, recordable: 0 };
                }
                siteData[site].total++;
                if (row.recordable === 1) {
                    siteData[site].recordable++;
                }
            });
            
            const siteRates = Object.entries(siteData)
                .map(([site, data]) => ({
                    site,
                    rate: ((data.recordable / data.total) * 100).toFixed(1)
                }))
                .sort((a, b) => b.rate - a.rate);
            
            chart.config.type = 'bar';
            chart.data = {
                labels: siteRates.map(s => s.site),
                datasets: [{
                    data: siteRates.map(s => parseFloat(s.rate)),
                    backgroundColor: 'rgba(255, 87, 34, 0.8)',
                    borderWidth: 1,
                    label: 'Recordable Rate %'
                }]
            };
            chart.options = getChartOptions('bar');
            chart.options.scales.y.max = 100;
            chart.update();
        }

        function updateSeverityBySiteChart(chart, data) {
            const siteData = {};
            data.forEach(row => {
                const site = row.site || 'Unknown';
                if (!siteData[site]) {
                    siteData[site] = { A: 0, B: 0, C: 0, D: 0 };
                }
                if (row.severity && siteData[site][row.severity] !== undefined) {
                    siteData[site][row.severity]++;
                }
            });
            
            const sites = Object.keys(siteData).sort();
            
            chart.config.type = 'bar';
            chart.data = {
                labels: sites,
                datasets: [
                    {
                        label: 'Severity A',
                        data: sites.map(site => siteData[site].A),
                        backgroundColor: SEVERITY_COLORS.A
                    },
                    {
                        label: 'Severity B',
                        data: sites.map(site => siteData[site].B),
                        backgroundColor: SEVERITY_COLORS.B
                    },
                    {
                        label: 'Severity C',
                        data: sites.map(site => siteData[site].C),
                        backgroundColor: SEVERITY_COLORS.C
                    },
                    {
                        label: 'Severity D',
                        data: sites.map(site => siteData[site].D),
                        backgroundColor: SEVERITY_COLORS.D
                    }
                ]
            };
            chart.options = getChartOptions('bar');
            chart.options.scales.x.stacked = true;
            chart.options.scales.y.stacked = true;
            chart.update();
        }

        function updateImpactTypeChart(chart, data) {
            const impactCounts = {};
            data.forEach(row => {
                const impact = row.initial_info_impact_type_primary || row.type || 'Unknown';
                impactCounts[impact] = (impactCounts[impact] || 0) + 1;
            });
            
            const topImpacts = Object.entries(impactCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 6);
            
            chart.config.type = 'pie';
            chart.data = {
                labels: topImpacts.map(([impact]) => impact),
                datasets: [{
                    data: topImpacts.map(([, count]) => count),
                    backgroundColor: [
                        'rgba(76, 175, 80, 0.8)',
                        'rgba(35, 47, 62, 0.8)',
                        'rgba(55, 71, 90, 0.8)',
                        'rgba(255, 87, 34, 0.8)',
                        'rgba(76, 175, 80, 0.8)',
                        'rgba(33, 150, 243, 0.8)'
                    ],
                    label: 'Cases'
                }]
            };
            chart.options = getChartOptions('pie');
            chart.update();
        }

        function updateBodyPartHeatmapChart(chart, data) {
            const bodyPartSeverity = {};
            data.forEach(row => {
                const part = row.bodyPart || 'Unknown';
                if (!bodyPartSeverity[part]) {
                    bodyPartSeverity[part] = { A: 0, B: 0, C: 0, D: 0 };
                }
                if (row.severity && bodyPartSeverity[part][row.severity] !== undefined) {
                    bodyPartSeverity[part][row.severity]++;
                }
            });
            
            const topBodyParts = Object.entries(bodyPartSeverity)
                .map(([part, severities]) => ({
                    part,
                    total: Object.values(severities).reduce((a, b) => a + b, 0),
                    severities
                }))
                .sort((a, b) => b.total - a.total)
                .slice(0, 10);
            
            chart.config.type = 'bar';
            chart.data = {
                labels: topBodyParts.map(bp => bp.part.substring(0, 20) + (bp.part.length > 20 ? '...' : '')),
                datasets: [
                    {
                        label: 'Severity A',
                        data: topBodyParts.map(bp => bp.severities.A),
                        backgroundColor: SEVERITY_COLORS.A
                    },
                    {
                        label: 'Severity B',
                        data: topBodyParts.map(bp => bp.severities.B),
                        backgroundColor: SEVERITY_COLORS.B
                    },
                    {
                        label: 'Severity C',
                        data: topBodyParts.map(bp => bp.severities.C),
                        backgroundColor: SEVERITY_COLORS.C
                    },
                    {
                        label: 'Severity D',
                        data: topBodyParts.map(bp => bp.severities.D),
                        backgroundColor: SEVERITY_COLORS.D
                    }
                ]
            };
            chart.options = getChartOptions('bar');
            chart.options.indexAxis = 'y';
            chart.options.scales.x.stacked = true;
            chart.options.scales.y.stacked = true;
            chart.update();
        }

        function updateRiskTrendChart(chart, data) {
            const monthlyRisk = {};
            data.forEach(row => {
                if (row.parsedDate && !isNaN(row.parsedDate)) {
                    const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
                    if (!monthlyRisk[monthKey]) {
                        monthlyRisk[monthKey] = { total: 0, count: 0 };
                    }
                    const risk = parseFloat(row.risk || calculateRiskScore(row));
                    if (!isNaN(risk)) {
                        monthlyRisk[monthKey].total += risk;
                        monthlyRisk[monthKey].count++;
                    }
                }
            });
            
            const sortedMonths = Object.keys(monthlyRisk).sort();
            const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            
            chart.config.type = 'line';
            chart.data = {
                labels: sortedMonths.map(m => {
                    const [year, month] = m.split('-');
                    return `${monthNames[parseInt(month)-1]} ${year}`;
                }),
                datasets: [{
                    label: 'Average Risk Score',
                    data: sortedMonths.map(m => 
                        monthlyRisk[m].count > 0 ? (monthlyRisk[m].total / monthlyRisk[m].count).toFixed(1) : 0
                    ),
                    borderColor: 'rgba(76, 175, 80, 1)',
                    backgroundColor: 'rgba(76, 175, 80, 0.1)',
                    tension: 0.3
                }]
            };
            chart.options = getChartOptions('line');
            chart.update();
        }

        // Near Miss specific charts
        function updateLocationChart(chart, data) {
            const locationCounts = {};
            data.forEach(row => {
                const location = row.location || 'Unknown';
                locationCounts[location] = (locationCounts[location] || 0) + 1;
            });
            
            const topLocations = Object.entries(locationCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            
            chart.config.type = 'bar';
            chart.data = {
                labels: topLocations.map(([location]) => 
                    location.substring(0, 30) + (location.length > 30 ? '...' : '')
                ),
                datasets: [{
                    data: topLocations.map(([, count]) => count),
                    backgroundColor: 'rgba(35, 47, 62, 0.8)',
                    borderColor: 'rgba(35, 47, 62, 1)',
                    borderWidth: 1,
                    label: 'Incidents'
                }]
            };
            chart.options = getChartOptions('bar');
            chart.options.indexAxis = 'y';
            chart.update();
        }

        function updateImpactChart(chart, data) {
            const impactCounts = {};
            data.forEach(row => {
                const impact = row.primaryImpact || 'Unknown';
                impactCounts[impact] = (impactCounts[impact] || 0) + 1;
            });
            
            const topImpacts = Object.entries(impactCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 6);
            
            chart.config.type = 'pie';
            chart.data = {
                labels: topImpacts.map(([impact]) => impact),
                datasets: [{
                    data: topImpacts.map(([, count]) => count),
                    backgroundColor: [
                        'rgba(76, 175, 80, 0.8)',
                        'rgba(35, 47, 62, 0.8)',
                        'rgba(55, 71, 90, 0.8)',
                        'rgba(255, 87, 34, 0.8)',
                        'rgba(76, 175, 80, 0.8)',
                        'rgba(33, 150, 243, 0.8)'
                    ],
                    label: 'Incidents'
                }]
            };
            chart.options = getChartOptions('pie');
            chart.update();
        }

        function updateLikelihoodChart(chart, data) {
            const likelihoodCounts = {};
            data.forEach(row => {
                const likelihood = row.standardized_likelihood || 'Unknown';
                likelihoodCounts[likelihood] = (likelihoodCounts[likelihood] || 0) + 1;
            });
            
            const likelihoods = ['Rare', 'Unlikely', 'Possible', 'Likely', 'Almost Certain'];
            
            chart.config.type = 'bar';
            chart.data = {
                labels: likelihoods,
                datasets: [{
                    data: likelihoods.map(l => likelihoodCounts[l] || 0),
                    backgroundColor: [
                        'rgba(76, 175, 80, 0.8)',
                        'rgba(139, 195, 74, 0.8)',
                        'rgba(255, 193, 7, 0.8)',
                        'rgba(255, 152, 0, 0.8)',
                        'rgba(255, 87, 34, 0.8)'
                    ],
                    label: 'Incidents'
                }]
            };
            chart.options = getChartOptions('bar');
            chart.update();
        }

        function updateProcessChart(chart, data) {
            const processCounts = {};
            data.forEach(row => {
                const process = row.processPath || 'Unknown';
                processCounts[process] = (processCounts[process] || 0) + 1;
            });
            
            const processes = Object.entries(processCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 8);
            
            chart.config.type = 'bar';
            chart.data = {
                labels: processes.map(([process]) => process),
                datasets: [{
                    data: processes.map(([, count]) => count),
                    backgroundColor: 'rgba(76, 175, 80, 0.8)',
                    borderColor: 'rgba(76, 175, 80, 1)',
                    borderWidth: 1,
                    label: 'Incidents'
                }]
            };
            chart.options = getChartOptions('bar');
            chart.update();
        }

        function updateImpactBySeverityChart(chart, data) {
            const impactSeverity = {};
            data.forEach(row => {
                const impact = row.primaryImpact || 'Unknown';
                if (!impactSeverity[impact]) {
                    impactSeverity[impact] = { A: 0, B: 0, C: 0, D: 0 };
                }
                if (row.severity && impactSeverity[impact][row.severity] !== undefined) {
                    impactSeverity[impact][row.severity]++;
                }
            });
            
            const topImpacts = Object.entries(impactSeverity)
                .map(([impact, severities]) => ({
                    impact,
                    total: Object.values(severities).reduce((a, b) => a + b, 0),
                    severities
                }))
                .sort((a, b) => b.total - a.total)
                .slice(0, 8);
            
            chart.config.type = 'bar';
            chart.data = {
                labels: topImpacts.map(i => i.impact),
                datasets: [
                    {
                        label: 'Severity A',
                        data: topImpacts.map(i => i.severities.A),
                        backgroundColor: SEVERITY_COLORS.A
                    },
                    {
                        label: 'Severity B',
                        data: topImpacts.map(i => i.severities.B),
                        backgroundColor: SEVERITY_COLORS.B
                    },
                    {
                        label: 'Severity C',
                        data: topImpacts.map(i => i.severities.C),
                        backgroundColor: SEVERITY_COLORS.C
                    },
                    {
                        label: 'Severity D',
                        data: topImpacts.map(i => i.severities.D),
                        backgroundColor: SEVERITY_COLORS.D
                    }
                ]
            };
            chart.options = getChartOptions('bar');
            chart.options.scales.x.stacked = true;
            chart.options.scales.y.stacked = true;
            chart.update();
        }

        function updateLocationHeatmapChart(chart, data) {
            const locationRisk = {};
            data.forEach(row => {
                const location = row.location || 'Unknown';
                if (!locationRisk[location]) {
                    locationRisk[location] = { total: 0, count: 0 };
                }
                const risk = parseFloat(row.risk || calculateRiskScore(row));
                if (!isNaN(risk)) {
                    locationRisk[location].total += risk;
                    locationRisk[location].count++;
                }
            });
            
            const topLocations = Object.entries(locationRisk)
                .map(([location, data]) => ({
                    location,
                    avgRisk: data.count > 0 ? (data.total / data.count).toFixed(1) : 0,
                    count: data.count
                }))
                .sort((a, b) => b.avgRisk - a.avgRisk)
                .slice(0, 10);
            
            chart.config.type = 'bar';
            chart.data = {
                labels: topLocations.map(l => l.location.substring(0, 30) + (l.location.length > 30 ? '...' : '')),
                datasets: [{
                    label: 'Average Risk Score',
                    data: topLocations.map(l => parseFloat(l.avgRisk)),
                    backgroundColor: topLocations.map(l => {
                        const risk = parseFloat(l.avgRisk);
                        if (risk >= 8) return SEVERITY_COLORS.A;
                        if (risk >= 6) return SEVERITY_COLORS.B;
                        if (risk >= 4) return SEVERITY_COLORS.C;
                        return SEVERITY_COLORS.D;
                    }),
                    borderWidth: 1
                }]
            };
            chart.options = getChartOptions('bar');
            chart.options.indexAxis = 'y';
            chart.update();
        }

        function updateRiskMatrixChart(chart, data) {
            const riskDistribution = {
                '0-2': 0,
                '2-4': 0,
                '4-6': 0,
                '6-8': 0,
                '8-10': 0
            };
            
            data.forEach(row => {
                const risk = parseFloat(row.risk || calculateRiskScore(row));
                if (risk <= 2) riskDistribution['0-2']++;
                else if (risk <= 4) riskDistribution['2-4']++;
                else if (risk <= 6) riskDistribution['4-6']++;
                else if (risk <= 8) riskDistribution['6-8']++;
                else riskDistribution['8-10']++;
            });
            
            chart.config.type = 'bar';
            chart.data = {
                labels: Object.keys(riskDistribution),
                datasets: [{
                    label: 'Number of Incidents',
                    data: Object.values(riskDistribution),
                    backgroundColor: [
                        SEVERITY_COLORS.D,
                        SEVERITY_COLORS.C,
                        SEVERITY_COLORS.C,
                        SEVERITY_COLORS.B,
                        SEVERITY_COLORS.A
                    ],
                    borderWidth: 1
                }]
            };
            chart.options = getChartOptions('bar');
            chart.update();
        }

        function updateHighRiskAreasChart(chart, data) {
            const highRiskData = data.filter(r => {
                const risk = parseFloat(r.risk || calculateRiskScore(r));
                return risk >= 7;
            });
            
            const areaCounts = {};
            highRiskData.forEach(row => {
                const key = `${row.location || 'Unknown'} - ${row.processPath || 'Unknown'}`;
                areaCounts[key] = (areaCounts[key] || 0) + 1;
            });
            
            const topAreas = Object.entries(areaCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            
            chart.config.type = 'bar';
            chart.data = {
                labels: topAreas.map(([area]) => area.substring(0, 40) + (area.length > 40 ? '...' : '')),
                datasets: [{
                    label: 'High Risk Incidents',
                    data: topAreas.map(([, count]) => count),
                    backgroundColor: 'rgba(183, 28, 28, 0.8)',
                    borderColor: 'rgba(183, 28, 28, 1)',
                    borderWidth: 1
                }]
            };
            chart.options = getChartOptions('bar');
            chart.options.indexAxis = 'y';
            chart.update();
        }

        function updatePreventionOpportunitiesChart(chart, data) {
            // Identify patterns for prevention
            const preventionData = {};
            
            // Group by root cause and severity
            data.forEach(row => {
                const factor = row.contributingFactor || 'Unknown';
                if (!preventionData[factor]) {
                    preventionData[factor] = {
                        total: 0,
                        highSeverity: 0,
                        preventable: 0
                    };
                }
                preventionData[factor].total++;
                if (row.severity === 'A' || row.severity === 'B') {
                    preventionData[factor].highSeverity++;
                }
                // Consider preventable if likelihood is not 'Rare'
                if (row.standardized_likelihood !== 'Rare') {
                    preventionData[factor].preventable++;
                }
            });
            
            const topOpportunities = Object.entries(preventionData)
                .map(([factor, data]) => ({
                    factor,
                    preventionScore: (data.preventable / data.total) * (data.highSeverity + 1)
                }))
                .sort((a, b) => b.preventionScore - a.preventionScore)
                .slice(0, 8);
            
            chart.config.type = 'bar';
            chart.data = {
                labels: topOpportunities.map(o => o.factor),
                datasets: [{
                    label: 'Prevention Priority Score',
                    data: topOpportunities.map(o => o.preventionScore.toFixed(1)),
                    backgroundColor: 'rgba(76, 175, 80, 0.8)',
                    borderColor: 'rgba(76, 175, 80, 1)',
                    borderWidth: 1
                }]
            };
            chart.options = getChartOptions('bar');
            chart.update();
        }

        // Quality Analysis Functions
        function updateNearMissQualityAnalysis() {
            if (state.nearMiss.filteredData.length === 0) {
                showStatus('No near miss data loaded for quality analysis', 'info');
                return;
            }
            
            const data = state.nearMiss.filteredData;
            
            // Calculate quality metrics
            const qualityMetrics = calculateQualityMetrics(data);
            
            // Update quality score
            const overallScore = calculateOverallQualityScore(qualityMetrics);
            const scoreElement = document.getElementById('overallQualityScore');
            scoreElement.textContent = overallScore + '%';
            scoreElement.className = 'quality-score ' + getQualityClass(overallScore);
            
            // Update metrics
            document.getElementById('avgDescLength').textContent = qualityMetrics.avgDescriptionLength.toFixed(0);
            document.getElementById('duplicateCount').textContent = qualityMetrics.duplicateDescriptions.length;
            document.getElementById('shortDescCount').textContent = qualityMetrics.shortDescriptions;
            document.getElementById('completeRecords').textContent = qualityMetrics.completenessRate.toFixed(1) + '%';
            
            // Update indicators
            updateQualityIndicators(qualityMetrics);
            
            // Update charts
            updateQualityCharts(data, qualityMetrics);
            
            // Update duplicate list
            updateDuplicateList(qualityMetrics.duplicateDescriptions);
            
            // Generate recommendations
            generateQualityRecommendations(qualityMetrics);
        }

        function calculateQualityMetrics(data) {
            // Description analysis
            const descriptions = data.map(r => r.description || '');
            const descriptionLengths = descriptions.map(d => d.length);
            const avgDescriptionLength = descriptionLengths.reduce((a, b) => a + b, 0) / descriptionLengths.length;
            
            // Find duplicates
            const descriptionCounts = {};
            descriptions.forEach(desc => {
                if (desc && desc !== 'No description available') {
                    descriptionCounts[desc] = (descriptionCounts[desc] || 0) + 1;
                }
            });
            
            const duplicateDescriptions = Object.entries(descriptionCounts)
                .filter(([desc, count]) => count > 1)
                .map(([desc, count]) => ({ description: desc, count: count }));
            
            // Short descriptions (less than 50 characters)
            const shortDescriptions = descriptionLengths.filter(len => len < 50).length;
            
            // Completeness
            const completeRecords = data.filter(r => r.hasCompleteData).length;
            const completenessRate = (completeRecords / data.length) * 100;
            
            // Common phrases analysis
            const commonPhrases = analyzeCommonPhrases(descriptions);
            
            // Quality by site
            const qualityBySite = {};
            data.forEach(row => {
                const site = row.site || 'Unknown';
                if (!qualityBySite[site]) {
                    qualityBySite[site] = {
                        total: 0,
                        complete: 0,
                        avgDescLength: 0,
                        shortDescs: 0
                    };
                }
                qualityBySite[site].total++;
                if (row.hasCompleteData) qualityBySite[site].complete++;
                qualityBySite[site].avgDescLength += row.descriptionLength || 0;
                if (row.descriptionLength < 50) qualityBySite[site].shortDescs++;
            });
            
            // Calculate averages for site quality
            Object.keys(qualityBySite).forEach(site => {
                qualityBySite[site].avgDescLength = qualityBySite[site].avgDescLength / qualityBySite[site].total;
                qualityBySite[site].completenessRate = (qualityBySite[site].complete / qualityBySite[site].total) * 100;
            });
            
            return {
                avgDescriptionLength,
                duplicateDescriptions,
                shortDescriptions,
                completenessRate,
                commonPhrases,
                qualityBySite,
                totalRecords: data.length
            };
        }

        function analyzeCommonPhrases(descriptions) {
            const phrases = {};
            const commonWords = ['the', 'and', 'or', 'in', 'on', 'at', 'to', 'a', 'an', 'of', 'for', 'with', 'by'];
            
            descriptions.forEach(desc => {
                if (desc && desc.length > 20) {
                    // Split into words and create 2-3 word phrases
                    const words = desc.toLowerCase().split(/\s+/).filter(w => w.length > 2 && !commonWords.includes(w));
                    
                    // 2-word phrases
                    for (let i = 0; i < words.length - 1; i++) {
                        const phrase = `${words[i]} ${words[i+1]}`;
                        phrases[phrase] = (phrases[phrase] || 0) + 1;
                    }
                    
                    // 3-word phrases
                    for (let i = 0; i < words.length - 2; i++) {
                        const phrase = `${words[i]} ${words[i+1]} ${words[i+2]}`;
                        phrases[phrase] = (phrases[phrase] || 0) + 1;
                    }
                }
            });
            
            return Object.entries(phrases)
                .filter(([phrase, count]) => count > 2)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
        }

        function calculateOverallQualityScore(metrics) {
            let score = 0;
            
            // Description length score (30%)
            if (metrics.avgDescriptionLength >= 100) score += 30;
            else if (metrics.avgDescriptionLength >= 75) score += 20;
            else if (metrics.avgDescriptionLength >= 50) score += 10;
            
            // Uniqueness score (25%)
            const duplicateRate = (metrics.duplicateDescriptions.length / metrics.totalRecords) * 100;
            if (duplicateRate < 1) score += 25;
            else if (duplicateRate < 5) score += 15;
            else if (duplicateRate < 10) score += 5;
            
            // Completeness score (30%)
            score += (metrics.completenessRate / 100) * 30;
            
            // Short description penalty (15%)
            const shortDescRate = (metrics.shortDescriptions / metrics.totalRecords) * 100;
            if (shortDescRate < 5) score += 15;
            else if (shortDescRate < 10) score += 10;
            else if (shortDescRate < 20) score += 5;
            
            return Math.round(score);
        }

        function getQualityClass(score) {
            if (score >= 80) return 'good';
            if (score >= 60) return 'medium';
            return 'poor';
        }

        function updateQualityIndicators(metrics) {
            // Description Quality
            const descQuality = metrics.avgDescriptionLength >= 75 ? 'Good' : 
                               metrics.avgDescriptionLength >= 50 ? 'Fair' : 'Poor';
            document.getElementById('descQualityIndicator').textContent = descQuality;
            document.getElementById('descQualityIndicator').style.color = 
                descQuality === 'Good' ? 'var(--success)' : 
                descQuality === 'Fair' ? 'var(--warning)' : 'var(--danger)';
            
            // Completeness
            const completeness = metrics.completenessRate >= 90 ? 'Excellent' :
                                metrics.completenessRate >= 75 ? 'Good' :
                                metrics.completenessRate >= 50 ? 'Fair' : 'Poor';
            document.getElementById('completenessIndicator').textContent = completeness;
            document.getElementById('completenessIndicator').style.color = 
                completeness === 'Excellent' ? 'var(--success)' :
                completeness === 'Good' ? 'var(--success)' :
                completeness === 'Fair' ? 'var(--warning)' : 'var(--danger)';
            
            // Duplicate Detection
            const duplicateRate = (metrics.duplicateDescriptions.length / metrics.totalRecords) * 100;
            const duplicateStatus = duplicateRate < 1 ? 'Minimal' :
                                   duplicateRate < 5 ? 'Low' :
                                   duplicateRate < 10 ? 'Moderate' : 'High';
            document.getElementById('duplicateIndicator').textContent = duplicateStatus;
            document.getElementById('duplicateIndicator').style.color = 
                duplicateStatus === 'Minimal' ? 'var(--success)' :
                duplicateStatus === 'Low' ? 'var(--success)' :
                duplicateStatus === 'Moderate' ? 'var(--warning)' : 'var(--danger)';
            
            // Risk Assessment Quality
            const missingRisk = state.nearMiss.filteredData.filter(r => !r.risk || r.risk === 0).length;
            const riskQuality = missingRisk === 0 ? 'Complete' :
                               missingRisk < 5 ? 'Good' :
                               missingRisk < 10 ? 'Fair' : 'Poor';
            document.getElementById('riskQualityIndicator').textContent = riskQuality;
            document.getElementById('riskQualityIndicator').style.color = 
                riskQuality === 'Complete' ? 'var(--success)' :
                riskQuality === 'Good' ? 'var(--success)' :
                riskQuality === 'Fair' ? 'var(--warning)' : 'var(--danger)';
        }

        function updateQualityCharts(data, metrics) {
            // Description Length Distribution
            const lengthChart = state.nearMiss.qualityCharts.descLengthChart;
            if (lengthChart) {
                const lengthRanges = {
                    '0-25': 0,
                    '26-50': 0,
                    '51-75': 0,
                    '76-100': 0,
                    '101-150': 0,
                    '150+': 0
                };
                
                data.forEach(row => {
                    const len = row.descriptionLength || 0;
                    if (len <= 25) lengthRanges['0-25']++;
                    else if (len <= 50) lengthRanges['26-50']++;
                    else if (len <= 75) lengthRanges['51-75']++;
                    else if (len <= 100) lengthRanges['76-100']++;
                    else if (len <= 150) lengthRanges['101-150']++;
                    else lengthRanges['150+']++;
                });
                
                lengthChart.data = {
                    labels: Object.keys(lengthRanges),
                    datasets: [{
                        label: 'Number of Descriptions',
                        data: Object.values(lengthRanges),
                        backgroundColor: 'rgba(76, 175, 80, 0.8)',
                        borderWidth: 1
                    }]
                };
                lengthChart.update();
            }
            
            // Quality by Site
            const siteChart = state.nearMiss.qualityCharts.qualityBySiteChart;
            if (siteChart) {
                const sites = Object.keys(metrics.qualityBySite);
                const avgLengths = sites.map(site => metrics.qualityBySite[site].avgDescLength);
                const completenessRates = sites.map(site => metrics.qualityBySite[site].completenessRate);
                
                siteChart.data = {
                    labels: sites,
                    datasets: [
                        {
                            label: 'Avg Description Length',
                            data: avgLengths,
                            backgroundColor: 'rgba(76, 175, 80, 0.8)',
                            yAxisID: 'y'
                        },
                        {
                            label: 'Completeness Rate %',
                            data: completenessRates,
                            backgroundColor: 'rgba(35, 47, 62, 0.8)',
                            yAxisID: 'y1'
                        }
                    ]
                };
                
                siteChart.options = getChartOptions('bar');
                siteChart.options.scales.y1 = {
                    type: 'linear',
                    display: true,
                    position: 'right',
                    grid: {
                        drawOnChartArea: false
                    },
                    ticks: {
                        color: state.theme === 'dark' ? '#ffffff' : '#212121'
                    }
                };
                siteChart.update();
            }
            
            // Common Phrases
            const phrasesChart = state.nearMiss.qualityCharts.commonPhrasesChart;
            if (phrasesChart && metrics.commonPhrases.length > 0) {
                phrasesChart.config.type = 'bar';
                phrasesChart.data = {
                    labels: metrics.commonPhrases.map(([phrase]) => phrase),
                    datasets: [{
                        label: 'Occurrences',
                        data: metrics.commonPhrases.map(([, count]) => count),
                        backgroundColor: 'rgba(255, 193, 7, 0.8)',
                        borderWidth: 1
                    }]
                };
                phrasesChart.options = getChartOptions('bar');
                phrasesChart.options.indexAxis = 'y';
                phrasesChart.update();
            }
            
            // Quality Trend
            const trendChart = state.nearMiss.qualityCharts.qualityTrendChart;
            if (trendChart) {
                const monthlyQuality = {};
                
                data.forEach(row => {
                    if (row.parsedDate && !isNaN(row.parsedDate)) {
                        const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
                        if (!monthlyQuality[monthKey]) {
                            monthlyQuality[monthKey] = {
                                totalLength: 0,
                                count: 0,
                                complete: 0
                            };
                        }
                        monthlyQuality[monthKey].totalLength += row.descriptionLength || 0;
                        monthlyQuality[monthKey].count++;
                        if (row.hasCompleteData) monthlyQuality[monthKey].complete++;
                    }
                });
                
                const sortedMonths = Object.keys(monthlyQuality).sort();
                const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
                
                trendChart.config.type = 'line';
                trendChart.data = {
                    labels: sortedMonths.map(m => {
                        const [year, month] = m.split('-');
                        return `${monthNames[parseInt(month)-1]} ${year}`;
                    }),
                    datasets: [
                        {
                            label: 'Avg Description Length',
                            data: sortedMonths.map(m => 
                                monthlyQuality[m].count > 0 ? 
                                (monthlyQuality[m].totalLength / monthlyQuality[m].count).toFixed(0) : 0
                            ),
                            borderColor: 'rgba(76, 175, 80, 1)',
                            backgroundColor: 'rgba(76, 175, 80, 0.1)',
                            tension: 0.3,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Completeness Rate %',
                            data: sortedMonths.map(m => 
                                monthlyQuality[m].count > 0 ? 
                                ((monthlyQuality[m].complete / monthlyQuality[m].count) * 100).toFixed(1) : 0
                            ),
                            borderColor: 'rgba(35, 47, 62, 1)',
                            backgroundColor: 'rgba(35, 47, 62, 0.1)',
                            tension: 0.3,
                            yAxisID: 'y1'
                        }
                    ]
                };
                
                trendChart.options = getChartOptions('line');
                trendChart.options.scales.y1 = {
                    type: 'linear',
                    display: true,
                    position: 'right',
                    grid: {
                        drawOnChartArea: false
                    },
                    ticks: {
                        color: state.theme === 'dark' ? '#ffffff' : '#212121'
                    }
                };
                trendChart.update();
            }
        }

        function updateDuplicateList(duplicates) {
            const listContainer = document.getElementById('duplicateList');
            
            if (duplicates.length === 0) {
                listContainer.innerHTML = '<p style="color: var(--text-secondary);">No duplicate descriptions found - excellent data quality!</p>';
                return;
            }
            
            listContainer.innerHTML = duplicates.map(dup => `
                <div class="duplicate-item">
                    <strong>Count: ${dup.count}</strong><br>
                    <span style="color: var(--text-secondary);">"${dup.description.substring(0, 100)}${dup.description.length > 100 ? '...' : ''}"</span>
                </div>
            `).join('');
        }

        function generateQualityRecommendations(metrics) {
            const recommendations = [];
            
            // Description length recommendations
            if (metrics.avgDescriptionLength < 50) {
                recommendations.push({
                    priority: 'high',
                    title: 'Improve Description Detail',
                    description: 'Average description length is only ' + metrics.avgDescriptionLength.toFixed(0) + ' characters. Encourage more detailed incident descriptions (minimum 75 characters recommended).'
                });
            } else if (metrics.avgDescriptionLength < 75) {
                recommendations.push({
                    priority: 'medium',
                    title: 'Enhance Description Quality',
                    description: 'Description length is fair but could be improved. Target 100+ characters for better incident understanding.'
                });
            }
            
            // Duplicate recommendations
            if (metrics.duplicateDescriptions.length > 5) {
                recommendations.push({
                    priority: 'high',
                    title: 'Address Copy-Paste Reporting',
                    description: `Found ${metrics.duplicateDescriptions.length} duplicate descriptions. Implement training on unique incident reporting.`
                });
            }
            
            // Completeness recommendations
            if (metrics.completenessRate < 80) {
                recommendations.push({
                    priority: 'high',
                    title: 'Improve Data Completeness',
                    description: `Only ${metrics.completenessRate.toFixed(1)}% of records have complete data. Focus on capturing all required fields.`
                });
            }
            
            // Site-specific recommendations
            Object.entries(metrics.qualityBySite).forEach(([site, data]) => {
                if (data.avgDescLength < 50) {
                    recommendations.push({
                        priority: 'medium',
                        title: `Site ${site} - Description Training Needed`,
                        description: `Average description length at ${site} is only ${data.avgDescLength.toFixed(0)} characters.`
                    });
                }
            });
            
            // Common phrases recommendations
            if (metrics.commonPhrases.length > 5) {
                const topPhrase = metrics.commonPhrases[0][0];
                recommendations.push({
                    priority: 'low',
                    title: 'Diversify Reporting Language',
                    description: `"${topPhrase}" appears ${metrics.commonPhrases[0][1]} times. Encourage varied descriptions.`
                });
            }
            
            // Render recommendations
            const container = document.getElementById('qualityRecommendations');
            container.innerHTML = recommendations.map(rec => `
                <div style="padding: 1rem; margin-bottom: 1rem; background: ${
                    rec.priority === 'high' ? 'rgba(255, 87, 34, 0.1)' :
                    rec.priority === 'medium' ? 'rgba(255, 193, 7, 0.1)' :
                    'rgba(33, 150, 243, 0.1)'
                }; border-radius: 8px; border-left: 4px solid ${
                    rec.priority === 'high' ? '#FF5722' :
                    rec.priority === 'medium' ? '#FFC107' :
                    '#2196F3'
                };">
                    <h4 style="margin-bottom: 0.5rem;">${rec.title}</h4>
                    <p style="margin: 0;">${rec.description}</p>
                </div>
            `).join('');
        }

        // Update Overview
        function updateOverview() {
            if (state.injury.rawData.length > 0 || state.nearMiss.rawData.length > 0) {
                document.getElementById('welcomeScreen').style.display = 'none';
                document.getElementById('kpiDashboard').style.display = 'block';
                document.getElementById('overviewMetrics').style.display = 'grid';
                document.getElementById('overviewCharts').style.display = 'grid';
                
                // Update metrics
                const totalIncidents = state.injury.filteredData.length + state.nearMiss.filteredData.length;
                document.getElementById('totalIncidents').textContent = totalIncidents;
                document.getElementById('injuryCount').textContent = state.injury.filteredData.length;
                document.getElementById('nearMissCount').textContent = state.nearMiss.filteredData.length;
                
                // Calculate overall risk score
                const allRisks = [
                    ...state.injury.filteredData.map(r => parseFloat(calculateRiskScore(r))),
                    ...state.nearMiss.filteredData.map(r => parseFloat(r.risk))
                ].filter(r => !isNaN(r));
                
                const avgRisk = allRisks.length > 0 ? 
                    (allRisks.reduce((a, b) => a + b, 0) / allRisks.length).toFixed(1) : '0.0';
                document.getElementById('riskScore').textContent = avgRisk;
                
                updateKPIs();
                updateOverviewCharts();
            }
        }

        function updateOverviewCharts() {
            // Update trend chart
            const trendChart = Chart.getChart("overviewTrendChart");
            if (trendChart) {
                const allData = [...state.injury.filteredData, ...state.nearMiss.filteredData];
                const monthlyData = {};
                
                allData.forEach(row => {
                    if (row.parsedDate && !isNaN(row.parsedDate)) {
                        const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
                        if (!monthlyData[monthKey]) {
                            monthlyData[monthKey] = { injury: 0, nearMiss: 0 };
                        }
                        if (row.case_number) {
                            monthlyData[monthKey].injury++;
                        } else {
                            monthlyData[monthKey].nearMiss++;
                        }
                    }
                });
                
                const sortedMonths = Object.keys(monthlyData).sort();
                const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
                
                trendChart.data = {
                    labels: sortedMonths.map(m => {
                        const [year, month] = m.split('-');
                        return `${monthNames[parseInt(month)-1]} ${year}`;
                    }),
                    datasets: [
                        {
                            label: 'Injuries',
                            data: sortedMonths.map(m => monthlyData[m].injury),
                            borderColor: 'rgba(255, 87, 34, 1)',
                            backgroundColor: 'rgba(255, 87, 34, 0.1)',
                            tension: 0.3
                        },
                        {
                            label: 'Near Misses',
                            data: sortedMonths.map(m => monthlyData[m].nearMiss),
                            borderColor: 'rgba(255, 193, 7, 1)',
                            backgroundColor: 'rgba(255, 193, 7, 0.1)',
                            tension: 0.3
                        }
                    ]
                };
                trendChart.update();
            }
            
            // Update site chart
            const siteChart = Chart.getChart("overviewSiteChart");
            if (siteChart) {
                const siteCounts = {};
                
                state.injury.filteredData.forEach(row => {
                    const site = row.site || 'Unknown';
                    if (!siteCounts[site]) siteCounts[site] = { injury: 0, nearMiss: 0 };
                    siteCounts[site].injury++;
                });
                
                state.nearMiss.filteredData.forEach(row => {
                    const site = row.site || 'Unknown';
                    if (!siteCounts[site]) siteCounts[site] = { injury: 0, nearMiss: 0 };
                    siteCounts[site].nearMiss++;
                });
                
                const sites = Object.keys(siteCounts).sort();
                
                siteChart.data = {
                    labels: sites,
                    datasets: [
                        {
                            label: 'Injuries',
                            data: sites.map(site => siteCounts[site].injury),
                            backgroundColor: 'rgba(255, 87, 34, 0.8)'
                        },
                        {
                            label: 'Near Misses',
                            data: sites.map(site => siteCounts[site].nearMiss),
                            backgroundColor: 'rgba(255, 193, 7, 0.8)'
                        }
                    ]
                };
                siteChart.update();
            }
        }

        // Risk Matrix Functions
        function createRiskMatrices() {
            createRiskMatrix('injuryRiskMatrixGrid');
            createRiskMatrix('nearMissRiskMatrixGrid');
            createRiskMatrix('combinedRiskMatrix');
        }

        function createRiskMatrix(elementId) {
            const matrix = document.getElementById(elementId);
            if (!matrix) return;
            
            matrix.innerHTML = '';
            
            const severityLabels = ['', 'A', 'B', 'C', 'D'];
            const likelihoodLabels = ['', 'Rare', 'Unlikely', 'Possible', 'Likely', 'Almost Certain'];
            
            for (let s = 0; s < 6; s++) {
                for (let l = 0; l < 6; l++) {
                    const cell = document.createElement('div');
                    
                    if (s === 0 && l === 0) {
                        cell.className = 'matrix-label';
                        cell.textContent = 'S/L';
                    } else if (s === 0) {
                        cell.className = 'matrix-label';
                        cell.textContent = likelihoodLabels[l];
                    } else if (l === 0) {
                        cell.className = 'matrix-label';
                        cell.textContent = severityLabels[s];
                    } else {
                        const risk = (5 - s) * l;
                        let riskClass = 'risk-low';
                        if (risk > 15) riskClass = 'risk-critical';
                        else if (risk > 10) riskClass = 'risk-high';
                        else if (risk > 5) riskClass = 'risk-medium';
                        
                        cell.className = `matrix-cell ${riskClass}`;
                        cell.textContent = '0';
                        cell.id = `${elementId}-${severityLabels[s]}-${likelihoodLabels[l]}`;
                        cell.onclick = () => showMatrixDetails(severityLabels[s], likelihoodLabels[l], elementId);
                    }
                    
                    matrix.appendChild(cell);
                }
            }
        }

        function updateInjuryRiskMatrix() {
            updateRiskMatrix(state.injury.filteredData, 'injuryRiskMatrixGrid');
        }

        function updateNearMissRiskMatrix() {
            updateRiskMatrix(state.nearMiss.filteredData, 'nearMissRiskMatrixGrid');
        }

        function updateRiskMatrix(data, matrixId) {
            // Reset all cells
            const severityLabels = ['A', 'B', 'C', 'D'];
            const likelihoodLabels = ['Rare', 'Unlikely', 'Possible', 'Likely', 'Almost Certain'];
            
            severityLabels.forEach(severity => {
                likelihoodLabels.forEach(likelihood => {
                    const cell = document.getElementById(`${matrixId}-${severity}-${likelihood}`);
                    if (cell) {
                        cell.textContent = '0';
                        cell.style.fontWeight = 'normal';
                    }
                });
            });
            
            // Count incidents
            const matrixCounts = {};
            
            data.forEach(incident => {
                const severity = incident.severity;
                const likelihood = incident.standardized_likelihood || 'Possible';
                
                if (['A', 'B', 'C', 'D'].includes(severity)) {
                    const key = `${severity}-${likelihood}`;
                    matrixCounts[key] = (matrixCounts[key] || 0) + 1;
                }
            });
            
            // Update cells with counts
            Object.entries(matrixCounts).forEach(([key, count]) => {
                const [severity, likelihood] = key.split('-');
                const cell = document.getElementById(`${matrixId}-${severity}-${likelihood}`);
                if (cell) {
                    cell.textContent = count.toString();
                    if (count > 0) {
                        cell.style.fontWeight = 'bold';
                        cell.style.fontSize = '1.2rem';
                    }
                }
            });
        }

        function showMatrixDetails(severity, likelihood, matrixId) {
            let data;
            let type;
            
            if (matrixId.includes('injury')) {
                data = state.injury.filteredData;
                type = 'Injury';
            } else if (matrixId.includes('nearMiss')) {
                data = state.nearMiss.filteredData;
                type = 'Near Miss';
            } else {
                data = [...state.injury.filteredData, ...state.nearMiss.filteredData];
                type = 'Combined';
            }
            
            const incidents = data.filter(r => 
                r.severity === severity && 
                r.standardized_likelihood === likelihood
            );
            
            if (incidents.length === 0) {
                showStatus(`No ${type.toLowerCase()} incidents found with Severity ${severity} and Likelihood ${likelihood}`, 'info');
                return;
            }
            
            // Show in modal
            const modal = document.getElementById('detailModal');
            const title = document.getElementById('modalTitle');
            const body = document.getElementById('modalBody');
            
            title.textContent = `${type} Incidents: Severity ${severity}, ${likelihood}`;
            
            body.innerHTML = `
                <p style="margin-bottom: 1rem;">Total incidents: ${incidents.length}</p>
                <div style="max-height: 400px; overflow-y: auto;">
                    ${incidents.map(incident => `
                        <div style="padding: 1rem; border-bottom: 1px solid var(--bg-secondary);">
                            <strong>${incident.case_number || incident.incident_id}</strong><br>
                            <span style="color: var(--text-secondary);">
                                Date: ${incident.incident_date || incident.nearmiss_date || 'N/A'}<br>
                                Site: ${incident.site || 'N/A'}<br>
                                ${incident.bodyPart ? `Body Part: ${incident.bodyPart}<br>` : ''}
                                ${incident.location ? `Location: ${incident.location}<br>` : ''}
                                ${incident.processPath ? `Process: ${incident.processPath}<br>` : ''}
                            </span>
                        </div>
                    `).join('')}
                </div>
            `;
            
            modal.style.display = 'block';
        }

        function closeModal() {
            document.getElementById('detailModal').style.display = 'none';
        }

        // Fixed PDF Generation Function
        function generatePDFReport(reportType) {
            showStatus('Generating professional PDF report...', 'info');
            
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF('p', 'mm', 'a4');
            
            // Professional styling
            const colors = {
                primary: [35, 47, 62],        // Dark blue
                secondary: [76, 175, 80],     // Green
                danger: [255, 87, 34],        // Orange
                warning: [255, 193, 7],       // Yellow
                text: [33, 33, 33],           // Dark gray
                lightGray: [117, 117, 117],   // Light gray
                background: [248, 248, 248]   // Light background
            };
            
            // Add Amazon WHS logo/header section
            doc.setFillColor(...colors.primary);
            doc.rect(0, 0, 210, 40, 'F');
            
            // Add title and metadata
            doc.setTextColor(255, 255, 255);
            doc.setFontSize(24);
            doc.setFont(undefined, 'bold');
            doc.text('SAFETY ANALYTICS REPORT', 20, 20);
            
            doc.setFontSize(12);
            doc.setFont(undefined, 'normal');
            doc.text(`${reportType.charAt(0).toUpperCase() + reportType.slice(1)} Analysis`, 20, 30);
            doc.text(`Generated: ${new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}`, 130, 20);
            doc.text(`Report Period: ${getReportPeriod()}`, 130, 27);
            
            // Add executive summary box
            let yPosition = 50;
            
            // Executive Summary Section
            doc.setFillColor(...colors.background);
            doc.rect(15, yPosition, 180, 40, 'F');
            doc.setDrawColor(...colors.primary);
            doc.setLineWidth(0.5);
            doc.rect(15, yPosition, 180, 40, 'S');
            
            doc.setTextColor(...colors.primary);
            doc.setFontSize(14);
            doc.setFont(undefined, 'bold');
            doc.text('EXECUTIVE OVERVIEW', 20, yPosition + 8);
            
            yPosition += 15;
            
            // Calculate key metrics
            const metrics = calculateExecutiveMetrics();
            
            // Add metric boxes
            const metricBoxWidth = 40;
            const metricBoxHeight = 20;
            const metricStartX = 20;
            
            // Draw metric boxes
            drawMetricBox(doc, metricStartX, yPosition, metricBoxWidth, metricBoxHeight, 
                'TRIR', metrics.trir, metrics.trirTrend, colors);
            drawMetricBox(doc, metricStartX + 45, yPosition, metricBoxWidth, metricBoxHeight, 
                'LTIR', metrics.ltir, metrics.ltirTrend, colors);
            drawMetricBox(doc, metricStartX + 90, yPosition, metricBoxWidth, metricBoxHeight, 
                'DAFW Rate', metrics.dafwr, metrics.dafwrTrend, colors);
            drawMetricBox(doc, metricStartX + 135, yPosition, metricBoxWidth, metricBoxHeight, 
                'NM Ratio', metrics.nmRatio + ':1', metrics.nmTrend, colors);
            
            yPosition += 35;
            
            // Key Performance Indicators Section
            if (reportType === 'injury' || reportType === 'combined' || reportType === 'executive') {
                doc.setFillColor(...colors.primary);
                doc.rect(15, yPosition, 180, 8, 'F');
                doc.setTextColor(255, 255, 255);
                doc.setFontSize(12);
                doc.setFont(undefined, 'bold');
                doc.text('INJURY & ILLNESS ANALYSIS', 20, yPosition + 6);
                
                yPosition += 15;
                
                // Add injury insights
                const injuryInsights = generateInjuryInsights();
                doc.setTextColor(...colors.text);
                doc.setFontSize(10);
                doc.setFont(undefined, 'normal');
                
                injuryInsights.forEach(insight => {
                    if (yPosition > 250) {
                        doc.addPage();
                        yPosition = 20;
                    }
                    
                    // Draw insight with icon
                    drawInsightBox(doc, 20, yPosition, 170, insight, colors);
                    yPosition += 15;
                });
                
                // Add injury trend chart
                yPosition += 5;
                if (yPosition > 180) {
                    doc.addPage();
                    yPosition = 20;
                }
                
                // Add visual chart representation
                drawTrendChart(doc, 20, yPosition, 170, 50, 'injury', colors);
                yPosition += 60;
                
                // Add severity distribution pie chart
                if (yPosition > 200) {
                    doc.addPage();
                    yPosition = 20;
                }
                drawPieChart(doc, 20, yPosition, 80, 60, 'injury-severity', colors);
                yPosition += 70;
                
                // Site performance comparison
                if (state.injury.filteredData.length > 0) {
                    const sitePerformance = calculateSitePerformance('injury');
                    
                    if (yPosition > 200) {
                        doc.addPage();
                        yPosition = 20;
                    }
                    
                    doc.setTextColor(...colors.primary);
                    doc.setFontSize(11);
                    doc.setFont(undefined, 'bold');
                    doc.text('Site Performance Comparison', 20, yPosition);
                    yPosition += 8;
                    
                    // Create site performance table
                    const siteTableData = sitePerformance.map(site => [
                        site.name,
                        site.incidents.toString(),
                        site.recordableRate + '%',
                        site.severity,
                        site.trend
                    ]);
                    
                    doc.autoTable({
                        head: [['Site', 'Incidents', 'Rec. Rate', 'Avg Severity', 'Trend']],
                        body: siteTableData,
                        startY: yPosition,
                        theme: 'grid',
                        headStyles: { 
                            fillColor: colors.primary,
                            fontSize: 9,
                            fontStyle: 'bold'
                        },
                        bodyStyles: {
                            fontSize: 9
                        },
                        columnStyles: {
                            0: { cellWidth: 30 },
                            1: { cellWidth: 25, halign: 'center' },
                            2: { cellWidth: 25, halign: 'center' },
                            3: { cellWidth: 30, halign: 'center' },
                            4: { cellWidth: 60 }
                        },
                        didDrawCell: function(data) {
                            // Color code severity cells
                            if (data.column.index === 3 && data.cell.section === 'body') {
                                const severity = data.cell.raw;
                                if (severity.includes('A') || severity.includes('B')) {
                                    doc.setTextColor(...colors.danger);
                                } else if (severity.includes('C')) {
                                    doc.setTextColor(...colors.warning);
                                } else {
                                    doc.setTextColor(...colors.secondary);
                                }
                            }
                            // Add trend arrows
                            if (data.column.index === 4 && data.cell.section === 'body') {
                                const trend = data.cell.raw;
                                if (trend.includes('↑')) {
                                    doc.setTextColor(...colors.danger);
                                } else if (trend.includes('↓')) {
                                    doc.setTextColor(...colors.secondary);
                                }
                            }
                        }
                    });
                    
                    yPosition = doc.lastAutoTable.finalY + 10;
                }
                
                // Add body part analysis bar chart
                if (yPosition > 200) {
                    doc.addPage();
                    yPosition = 20;
                }
                drawBarChart(doc, 20, yPosition, 170, 60, 'injury-bodypart', colors);
                yPosition += 70;
            }
            
            // Near Miss Analysis Section
            if ((reportType === 'nearmiss' || reportType === 'combined' || reportType === 'executive') && 
                state.nearMiss.filteredData.length > 0) {
                
                if (yPosition > 200) {
                    doc.addPage();
                    yPosition = 20;
                }
                
                doc.setFillColor(...colors.primary);
                doc.rect(15, yPosition, 180, 8, 'F');
                doc.setTextColor(255, 255, 255);
                doc.setFontSize(12);
                doc.setFont(undefined, 'bold');
                doc.text('NEAR MISS ANALYSIS', 20, yPosition + 6);
                
                yPosition += 15;
                
                // Near miss insights
                const nearMissInsights = generateNearMissInsights();
                doc.setTextColor(...colors.text);
                doc.setFontSize(10);
                doc.setFont(undefined, 'normal');
                
                nearMissInsights.forEach(insight => {
                    if (yPosition > 250) {
                        doc.addPage();
                        yPosition = 20;
                    }
                    
                    drawInsightBox(doc, 20, yPosition, 170, insight, colors);
                    yPosition += 15;
                });
                
                // Risk matrix visualization
                yPosition += 5;
                if (yPosition > 180) {
                    doc.addPage();
                    yPosition = 20;
                }
                
                drawRiskMatrixVisualization(doc, 20, yPosition, 170, 60, colors);
                yPosition += 70;
                
                // Add location analysis chart
                if (yPosition > 200) {
                    doc.addPage();
                    yPosition = 20;
                }
                drawBarChart(doc, 20, yPosition, 170, 60, 'nearmiss-location', colors);
                yPosition += 70;
            }
            
            // Recommendations Section
            if (yPosition > 180) {
                doc.addPage();
                yPosition = 20;
            }
            
            doc.setFillColor(...colors.primary);
            doc.rect(15, yPosition, 180, 8, 'F');
            doc.setTextColor(255, 255, 255);
            doc.setFontSize(12);
            doc.setFont(undefined, 'bold');
            doc.text('ACTIONABLE RECOMMENDATIONS', 20, yPosition + 6);
            
            yPosition += 15;
            
            const recommendations = generateRecommendations(reportType);
            
            recommendations.forEach((rec, index) => {
                if (yPosition > 240) {
                    doc.addPage();
                    yPosition = 20;
                }
                
                // Priority indicator
                const priorityColor = rec.priority === 'High' ? colors.danger : 
                                    rec.priority === 'Medium' ? colors.warning : colors.secondary;
                
                doc.setFillColor(...priorityColor);
                doc.circle(22, yPosition + 3, 2, 'F');
                
                doc.setTextColor(...colors.text);
                doc.setFontSize(10);
                doc.setFont(undefined, 'bold');
                doc.text(`${index + 1}. ${rec.title}`, 28, yPosition + 5);
                
                doc.setFont(undefined, 'normal');
                doc.setFontSize(9);
                const lines = doc.splitTextToSize(rec.description, 160);
                doc.text(lines, 28, yPosition + 10);
                
                yPosition += 10 + (lines.length * 4) + 5;
            });
            
            // Trend Predictions Section
            if (reportType === 'executive' || reportType === 'combined') {
                if (yPosition > 200) {
                    doc.addPage();
                    yPosition = 20;
                }
                
                doc.setFillColor(...colors.primary);
                doc.rect(15, yPosition, 180, 8, 'F');
                doc.setTextColor(255, 255, 255);
                doc.setFontSize(12);
                doc.setFont(undefined, 'bold');
                doc.text('PREDICTIVE INSIGHTS', 20, yPosition + 6);
                
                yPosition += 15;
                
                const predictions = generatePredictions();
                doc.setTextColor(...colors.text);
                doc.setFontSize(10);
                
                predictions.forEach(prediction => {
                    if (yPosition > 250) {
                        doc.addPage();
                        yPosition = 20;
                    }
                    
                    doc.setFont(undefined, 'normal');
                    const predictionText = `• ${prediction}`;
                    const lines = doc.splitTextToSize(predictionText, 170);
                    doc.text(lines, 20, yPosition);
                    yPosition += lines.length * 5 + 3;
                });
            }
            
            // Add professional footer to all pages
            const pageCount = doc.internal.getNumberOfPages();
            for (let i = 1; i <= pageCount; i++) {
                doc.setPage(i);
                
                // Footer background
                doc.setFillColor(...colors.background);
                doc.rect(0, 280, 210, 17, 'F');
                
                // Footer content
                doc.setDrawColor(...colors.lightGray);
                doc.setLineWidth(0.5);
                doc.line(15, 282, 195, 282);
                
                doc.setFontSize(8);
                doc.setTextColor(...colors.lightGray);
                doc.text('Safety Analytics Platform | Amazon WHS', 20, 288);
                doc.text(`Page ${i} of ${pageCount}`, 105, 288, { align: 'center' });
                doc.text('Confidential - Internal Use Only', 190, 288, { align: 'right' });
                
                doc.setFontSize(7);
                doc.text(`Report ID: SAP-${reportType.toUpperCase()}-${new Date().getTime()}`, 20, 293);
                doc.text(`Generated by: ${getCurrentUser()}`, 105, 293, { align: 'center' });
                doc.text(new Date().toLocaleString(), 190, 293, { align: 'right' });
            }
            
            // Save the PDF
            const filename = `WHS-Safety-Report-${reportType}-${new Date().toISOString().split('T')[0]}.pdf`;
            doc.save(filename);
            showStatus('Professional PDF report generated successfully!', 'success');
            
            // Add to report history
            addToReportHistory(reportType.charAt(0).toUpperCase() + reportType.slice(1));
        }
        
        // Helper functions for professional PDF
        function drawMetricBox(doc, x, y, width, height, label, value, trend, colors) {
            // Box background
            doc.setFillColor(255, 255, 255);
            doc.rect(x, y, width, height, 'F');
            doc.setDrawColor(...colors.lightGray);
            doc.setLineWidth(0.3);
            doc.rect(x, y, width, height, 'S');
            
            // Label
            doc.setTextColor(...colors.lightGray);
            doc.setFontSize(8);
            doc.setFont(undefined, 'normal');
            doc.text(label, x + width/2, y + 5, { align: 'center' });
            
            // Value
            doc.setTextColor(...colors.primary);
            doc.setFontSize(16);
            doc.setFont(undefined, 'bold');
            doc.text(value.toString(), x + width/2, y + 13, { align: 'center' });
            
            // Trend indicator
            if (trend !== null) {
                const trendColor = trend > 0 ? colors.danger : colors.secondary;
                const trendSymbol = trend > 0 ? '↑' : trend < 0 ? '↓' : '→';
                const trendText = `${trendSymbol} ${Math.abs(trend)}%`;
                
                doc.setTextColor(...trendColor);
                doc.setFontSize(8);
                doc.setFont(undefined, 'normal');
                doc.text(trendText, x + width/2, y + 18, { align: 'center' });
            }
        }
        
        function drawInsightBox(doc, x, y, width, insight, colors) {
            const iconColor = insight.type === 'positive' ? colors.secondary :
                            insight.type === 'warning' ? colors.warning :
                            insight.type === 'critical' ? colors.danger : colors.text;
            
            // Draw icon
            doc.setFillColor(...iconColor);
            doc.circle(x + 3, y + 3, 1.5, 'F');
            
            // Draw text
            doc.setTextColor(...colors.text);
            doc.setFontSize(9);
            doc.setFont(undefined, 'bold');
            doc.text(insight.title, x + 8, y + 4);
            
            doc.setFont(undefined, 'normal');
            doc.setFontSize(8);
            const lines = doc.splitTextToSize(insight.content, width - 8);
            doc.text(lines, x + 8, y + 8);
        }
        
        function drawTrendChart(doc, x, y, width, height, type, colors) {
            // Draw chart area
            doc.setFillColor(...colors.background);
            doc.rect(x, y, width, height, 'F');
            doc.setDrawColor(...colors.lightGray);
            doc.setLineWidth(0.3);
            doc.rect(x, y, width, height, 'S');
            
            // Get monthly data
            const monthlyData = {};
            const data = type === 'injury' ? state.injury.filteredData : state.nearMiss.filteredData;
            
            data.forEach(row => {
                if (row.parsedDate && !isNaN(row.parsedDate)) {
                    const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
                    monthlyData[monthKey] = (monthlyData[monthKey] || 0) + 1;
                }
            });
            
            const sortedMonths = Object.keys(monthlyData).sort().slice(-6); // Last 6 months
            if (sortedMonths.length === 0) return;
            
            const maxValue = Math.max(...sortedMonths.map(m => monthlyData[m]));
            const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            
            // Draw axes
            doc.setDrawColor(...colors.text);
            doc.setLineWidth(0.5);
            doc.line(x + 10, y + height - 10, x + width - 10, y + height - 10); // X-axis
            doc.line(x + 10, y + 10, x + 10, y + height - 10); // Y-axis
            
            // Draw data points and lines
            const chartWidth = width - 20;
            const chartHeight = height - 20;
            const xStep = chartWidth / (sortedMonths.length - 1);
            
            doc.setDrawColor(...colors.primary);
            doc.setFillColor(...colors.primary);
            doc.setLineWidth(1);
            
            sortedMonths.forEach((month, index) => {
                const xPos = x + 10 + (index * xStep);
                const yPos = y + height - 10 - ((monthlyData[month] / maxValue) * chartHeight);
                
                // Draw point
                doc.circle(xPos, yPos, 1.5, 'F');
                
                // Draw line to next point
                if (index < sortedMonths.length - 1) {
                    const nextX = x + 10 + ((index + 1) * xStep);
                    const nextY = y + height - 10 - ((monthlyData[sortedMonths[index + 1]] / maxValue) * chartHeight);
                    doc.line(xPos, yPos, nextX, nextY);
                }
                
                // Add month label
                const [year, monthNum] = month.split('-');
                doc.setFontSize(7);
                doc.setTextColor(...colors.lightGray);
                doc.text(monthNames[parseInt(monthNum) - 1], xPos, y + height - 3, { align: 'center' });
                
                // Add value label
                doc.setFontSize(7);
                doc.setTextColor(...colors.primary);
                doc.text(monthlyData[month].toString(), xPos, yPos - 3, { align: 'center' });
            });
            
            // Add title
            doc.setFontSize(9);
            doc.setFont(undefined, 'bold');
            doc.setTextColor(...colors.text);
            doc.text(`${type === 'injury' ? 'Injury' : 'Near Miss'} Trend - Last 6 Months`, x + width/2, y + 5, { align: 'center' });
        }
        
        function drawPieChart(doc, x, y, width, height, chartType, colors) {
            // Draw chart area
            doc.setFillColor(...colors.background);
            doc.rect(x, y, width, height, 'F');
            doc.setDrawColor(...colors.lightGray);
            doc.setLineWidth(0.3);
            doc.rect(x, y, width, height, 'S');
            
            // Get data based on chart type
            let data = {};
            let title = '';
            
            if (chartType === 'injury-severity') {
                state.injury.filteredData.forEach(row => {
                    const severity = row.severity || 'Unknown';
                    data[severity] = (data[severity] || 0) + 1;
                });
                title = 'Severity Distribution';
            }
            
            // Calculate percentages
            const total = Object.values(data).reduce((a, b) => a + b, 0);
            if (total === 0) return;
            
            const centerX = x + width / 2;
            const centerY = y + height / 2 + 5;
            const radius = Math.min(width, height) * 0.3;
            
            // Draw pie slices
            let currentAngle = -Math.PI / 2; // Start from top
            const pieColors = [colors.danger, colors.warning, colors.secondary, colors.primary];
            
            Object.entries(data).forEach(([label, value], index) => {
                const percentage = value / total;
                const endAngle = currentAngle + (percentage * 2 * Math.PI);
                
                // Draw slice
                doc.setFillColor(...pieColors[index % pieColors.length]);
                doc.setDrawColor(...colors.lightGray);
                doc.setLineWidth(0.3);
                
                // Draw arc (approximated with lines)
                const steps = Math.max(20, Math.floor(percentage * 100));
                const angleStep = (endAngle - currentAngle) / steps;
                
                doc.moveTo(centerX, centerY);
                for (let i = 0; i <= steps; i++) {
                    const angle = currentAngle + (i * angleStep);
                    const x1 = centerX + Math.cos(angle) * radius;
                    const y1 = centerY + Math.sin(angle) * radius;
                    doc.lineTo(x1, y1);
                }
                doc.lineTo(centerX, centerY);
                doc.fill('evenodd');
                
                // Add label
                const labelAngle = currentAngle + ((endAngle - currentAngle) / 2);
                const labelX = centerX + Math.cos(labelAngle) * (radius * 0.7);
                const labelY = centerY + Math.sin(labelAngle) * (radius * 0.7);
                
                doc.setTextColor(255, 255, 255);
                doc.setFontSize(8);
                doc.setFont(undefined, 'bold');
                doc.text(`${label}: ${value}`, labelX, labelY, { align: 'center' });
                
                currentAngle = endAngle;
            });
            
            // Add title
            doc.setFontSize(9);
            doc.setFont(undefined, 'bold');
            doc.setTextColor(...colors.text);
            doc.text(title, x + width/2, y + 5, { align: 'center' });
        }
        
        function drawBarChart(doc, x, y, width, height, chartType, colors) {
            // Draw chart area
            doc.setFillColor(...colors.background);
            doc.rect(x, y, width, height, 'F');
            doc.setDrawColor(...colors.lightGray);
            doc.setLineWidth(0.3);
            doc.rect(x, y, width, height, 'S');
            
            // Get data based on chart type
            let data = {};
            let title = '';
            
            if (chartType === 'injury-bodypart') {
                state.injury.filteredData.forEach(row => {
                    const part = row.bodyPart || 'Unknown';
                    data[part] = (data[part] || 0) + 1;
                });
                title = 'Top 5 Body Parts Affected';
            } else if (chartType === 'nearmiss-location') {
                state.nearMiss.filteredData.forEach(row => {
                    const location = row.location || 'Unknown';
                    data[location] = (data[location] || 0) + 1;
                });
                title = 'Top 5 Near Miss Locations';
            }
            
            // Get top 5
            const topData = Object.entries(data)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5);
            
            if (topData.length === 0) return;
            
            const maxValue = Math.max(...topData.map(([, value]) => value));
            const barWidth = (width - 30) / topData.length;
            const chartHeight = height - 25;
            
            // Draw bars
            topData.forEach(([label, value], index) => {
                const barHeight = (value / maxValue) * chartHeight;
                const barX = x + 15 + (index * barWidth) + (barWidth * 0.1);
                const barY = y + height - 15 - barHeight;
                const actualBarWidth = barWidth * 0.8;
                
                // Draw bar
                doc.setFillColor(...colors.primary);
                doc.rect(barX, barY, actualBarWidth, barHeight, 'F');
                
                // Add value on top
                doc.setTextColor(...colors.text);
                doc.setFontSize(8);
                doc.setFont(undefined, 'bold');
                doc.text(value.toString(), barX + actualBarWidth/2, barY - 2, { align: 'center' });
                
                // Add label
                doc.setFontSize(7);
                doc.setFont(undefined, 'normal');
                const shortLabel = label.length > 10 ? label.substring(0, 10) + '...' : label;
                doc.text(shortLabel, barX + actualBarWidth/2, y + height - 5, { align: 'center', angle: 0 });
            });
            
            // Add title
            doc.setFontSize(9);
            doc.setFont(undefined, 'bold');
            doc.setTextColor(...colors.text);
            doc.text(title, x + width/2, y + 5, { align: 'center' });
        }
        
        function drawRiskMatrixVisualization(doc, x, y, width, height, colors) {
            // Draw risk matrix grid
            const cellWidth = width / 5;
            const cellHeight = height / 5;
            
            // Risk levels colors with transparency (using lighter versions instead of alpha)
            const riskColors = {
                low: [200, 230, 201],      // Light Green
                medium: [255, 241, 179],   // Light Yellow
                high: [255, 213, 179],     // Light Orange
                critical: [255, 199, 190]  // Light Red
            };
            
            // Create risk matrix data
            const matrixData = {};
            state.nearMiss.filteredData.forEach(row => {
                const severity = row.severity;
                const likelihood = row.standardized_likelihood || 'Possible';
                const key = `${severity}-${likelihood}`;
                matrixData[key] = (matrixData[key] || 0) + 1;
            });
            
            // Draw grid
            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < 5; col++) {
                    const xPos = x + col * cellWidth;
                    const yPos = y + row * cellHeight;
                    
                    // Determine risk level
                    const risk = (5 - row) * (col + 1);
                    let fillColor;
                    if (risk <= 5) fillColor = riskColors.low;
                    else if (risk <= 10) fillColor = riskColors.medium;
                    else if (risk <= 15) fillColor = riskColors.high;
                    else fillColor = riskColors.critical;
                    
                    // Draw cell with light background color (no transparency needed)
                    doc.setFillColor(...fillColor);
                    doc.rect(xPos, yPos, cellWidth, cellHeight, 'F');
                    
                    doc.setDrawColor(...colors.lightGray);
                    doc.setLineWidth(0.3);
                    doc.rect(xPos, yPos, cellWidth, cellHeight, 'S');
                }
            }
            
            // Add labels
            const severityLabels = ['D', 'C', 'B', 'A'];
            const likelihoodLabels = ['Rare', 'Unlikely', 'Possible', 'Likely', 'Almost\nCertain'];
            
            doc.setFontSize(8);
            doc.setTextColor(...colors.text);
            
            // Severity labels (left side)
            severityLabels.forEach((label, index) => {
                doc.text(label, x - 5, y + (index + 0.5) * cellHeight + 2);
            });
            
            // Likelihood labels (bottom)
            likelihoodLabels.forEach((label, index) => {
                const lines = label.split('\n');
                lines.forEach((line, lineIndex) => {
                    doc.text(line, x + (index + 0.5) * cellWidth, y + height + 5 + (lineIndex * 3), { align: 'center' });
                });
            });
            
            // Add incident counts
            Object.entries(matrixData).forEach(([key, count]) => {
                const [severity, likelihood] = key.split('-');
                const severityIndex = severityLabels.indexOf(severity);
                const likelihoodIndex = ['Rare', 'Unlikely', 'Possible', 'Likely', 'Almost Certain'].indexOf(likelihood);
                
                if (severityIndex >= 0 && likelihoodIndex >= 0) {
                    const xPos = x + likelihoodIndex * cellWidth + cellWidth / 2;
                    const yPos = y + severityIndex * cellHeight + cellHeight / 2;
                    
                    doc.setFillColor(255, 255, 255);
                    doc.circle(xPos, yPos, 8, 'F');
                    
                    doc.setTextColor(...colors.primary);
                    doc.setFontSize(10);
                    doc.setFont(undefined, 'bold');
                    doc.text(count.toString(), xPos, yPos + 1, { align: 'center' });
                }
            });
            
            // Add title
            doc.setFontSize(9);
            doc.setFont(undefined, 'bold');
            doc.setTextColor(...colors.text);
            doc.text('Risk Matrix Distribution', x + width/2, y - 5, { align: 'center' });
        }
        
        function calculateExecutiveMetrics() {
            const hoursWorked = 200000; // Standard baseline
            
            // Current period metrics
            const recordableCount = state.injury.filteredData.filter(r => r.recordable === 1).length;
            const lostTimeCount = state.injury.filteredData.filter(r => r.total_dafw_days > 0).length;
            const totalDaysLost = state.injury.filteredData.reduce((sum, r) => sum + (r.total_dafw_days || 0), 0);
            const nearMissCount = state.nearMiss.filteredData.length;
            const injuryCount = state.injury.filteredData.length;
            
            // Calculate rates
            const trir = ((recordableCount / hoursWorked) * 200000).toFixed(2);
            const ltir = ((lostTimeCount / hoursWorked) * 200000).toFixed(2);
            const dafwr = ((totalDaysLost / hoursWorked) * 200000).toFixed(2);
            const nmRatio = injuryCount > 0 ? (nearMissCount / injuryCount).toFixed(1) : nearMissCount;
            
            // Calculate trends (mock data for demonstration)
            const trirTrend = -12; // 12% improvement
            const ltirTrend = -8;  // 8% improvement
            const dafwrTrend = -15; // 15% improvement
            const nmTrend = 25;    // 25% increase (good)
            
            return {
                trir,
                ltir,
                dafwr,
                nmRatio,
                trirTrend,
                ltirTrend,
                dafwrTrend,
                nmTrend
            };
        }
        
        function generateInjuryInsights() {
            const insights = [];
            const data = state.injury.filteredData;
            
            // Recordable rate insight
            const recordableRate = data.length > 0 ? 
                ((data.filter(r => r.recordable === 1).length / data.length) * 100).toFixed(1) : 0;
            
            if (recordableRate > 50) {
                insights.push({
                    type: 'critical',
                    title: 'High Recordable Rate Alert',
                    content: `${recordableRate}% of injuries are recordable. This exceeds industry benchmarks and requires immediate intervention.`
                });
            } else if (recordableRate < 30) {
                insights.push({
                    type: 'positive',
                    title: 'Recordable Rate Performance',
                    content: `Recordable rate at ${recordableRate}% is below industry average, indicating effective injury prevention measures.`
                });
            }
            
            // Body part analysis
            const bodyPartCounts = {};
            data.forEach(row => {
                const part = row.bodyPart || 'Unknown';
                bodyPartCounts[part] = (bodyPartCounts[part] || 0) + 1;
            });
            
            const topBodyPart = Object.entries(bodyPartCounts)
                .sort((a, b) => b[1] - a[1])[0];
            
            if (topBodyPart && topBodyPart[1] > 5) {
                insights.push({
                    type: 'warning',
                    title: 'Repetitive Injury Pattern',
                    content: `${topBodyPart[0]} injuries account for ${((topBodyPart[1] / data.length) * 100).toFixed(0)}% of all cases. Consider targeted ergonomic interventions.`
                });
            }
            
            // OTR analysis
            const otrCount = data.filter(r => r.otr === 'yes').length;
            if (otrCount > 0) {
                insights.push({
                    type: 'warning',
                    title: 'On-The-Road Safety Concern',
                    content: `${otrCount} injuries occurred while driving. Review vehicle safety protocols and driver training programs.`
                });
            }
            
            // Severity trends
            const highSeverity = data.filter(r => r.severity === 'A' || r.severity === 'B').length;
            if (highSeverity > data.length * 0.2) {
                insights.push({
                    type: 'critical',
                    title: 'Elevated Severity Levels',
                    content: `${((highSeverity / data.length) * 100).toFixed(0)}% of injuries are high severity (A/B). Focus on preventing serious incidents.`
                });
            }
            
            return insights;
        }
        
        function generateNearMissInsights() {
            const insights = [];
            const data = state.nearMiss.filteredData;
            
            // Risk score analysis
            const highRiskCount = data.filter(r => parseFloat(r.risk) >= 7).length;
            if (highRiskCount > 0) {
                insights.push({
                    type: 'critical',
                    title: 'High Risk Near Misses',
                    content: `${highRiskCount} near misses have risk scores ≥7. These require immediate corrective actions to prevent injuries.`
                });
            }
            
            // Location patterns
            const locationCounts = {};
            data.forEach(row => {
                const location = row.location || 'Unknown';
                locationCounts[location] = (locationCounts[location] || 0) + 1;
            });
            
            const repeatLocations = Object.entries(locationCounts)
                .filter(([, count]) => count >= 3)
                .sort((a, b) => b[1] - a[1]);
            
            if (repeatLocations.length > 0) {
                insights.push({
                    type: 'warning',
                    title: 'Recurring Risk Locations',
                    content: `${repeatLocations[0][0]} has ${repeatLocations[0][1]} near misses. Conduct detailed hazard assessment for this area.`
                });
            }
            
            // Near miss to injury ratio
            const nmRatio = state.injury.filteredData.length > 0 ? 
                (data.length / state.injury.filteredData.length).toFixed(1) : data.length;
            
            if (nmRatio < 3) {
                insights.push({
                    type: 'warning',
                    title: 'Low Near Miss Reporting',
                    content: `Near miss to injury ratio is ${nmRatio}:1. Industry best practice is 10:1. Enhance near miss reporting culture.`
                });
            } else if (nmRatio > 10) {
                insights.push({
                    type: 'positive',
                    title: 'Strong Safety Culture',
                    content: `Near miss to injury ratio of ${nmRatio}:1 indicates proactive hazard identification and reporting.`
                });
            }
            
            return insights;
        }
        
        function calculateSitePerformance(type) {
            const data = type === 'injury' ? state.injury.filteredData : state.nearMiss.filteredData;
            const siteStats = {};
            
            data.forEach(row => {
                const site = row.site || 'Unknown';
                if (!siteStats[site]) {
                    siteStats[site] = {
                        name: site,
                        incidents: 0,
                        recordable: 0,
                        severityA: 0,
                        severityB: 0,
                        severityC: 0,
                        severityD: 0,
                        monthlyData: {}
                    };
                }
                
                siteStats[site].incidents++;
                if (row.recordable === 1) siteStats[site].recordable++;
                
                if (row.severity === 'A') siteStats[site].severityA++;
                else if (row.severity === 'B') siteStats[site].severityB++;
                else if (row.severity === 'C') siteStats[site].severityC++;
                else if (row.severity === 'D') siteStats[site].severityD++;
                
                // Track monthly trend
                if (row.parsedDate) {
                    const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
                    siteStats[site].monthlyData[monthKey] = (siteStats[site].monthlyData[monthKey] || 0) + 1;
                }
            });
            
            // Calculate metrics and trends
            return Object.values(siteStats).map(site => {
                const recordableRate = site.incidents > 0 ? 
                    ((site.recordable / site.incidents) * 100).toFixed(1) : '0.0';
                
                // Determine predominant severity
                let severity = 'D';
                if (site.severityA > 0) severity = 'A-Heavy';
                else if (site.severityB > site.severityC && site.severityB > site.severityD) severity = 'B-Heavy';
                else if (site.severityC > site.severityD) severity = 'C-Heavy';
                
                // Calculate trend
                const months = Object.keys(site.monthlyData).sort();
                let trend = '→ Stable';
                if (months.length >= 2) {
                    const recent = site.monthlyData[months[months.length - 1]];
                    const previous = site.monthlyData[months[months.length - 2]];
                    if (recent > previous) trend = '↑ Increasing - Requires attention';
                    else if (recent < previous) trend = '↓ Improving';
                }
                
                return {
                    name: site.name,
                    incidents: site.incidents,
                    recordableRate,
                    severity,
                    trend
                };
            }).sort((a, b) => b.incidents - a.incidents);
        }
        
        function generateRecommendations(reportType) {
            const recommendations = [];
            
            if (reportType === 'injury' || reportType === 'combined' || reportType === 'executive') {
                // Injury-based recommendations
                const injuryData = state.injury.filteredData;
                
                // High severity recommendation
                const highSeverity = injuryData.filter(r => r.severity === 'A' || r.severity === 'B').length;
                if (highSeverity > 5) {
                    recommendations.push({
                        priority: 'High',
                        title: 'Implement Critical Control Management',
                        description: `With ${highSeverity} high-severity injuries, establish critical control verification protocols for high-risk activities. Focus on eliminating exposure to life-threatening hazards.`
                    });
                }
                
                // Body part specific
                const bodyPartCounts = {};
                injuryData.forEach(row => {
                    const part = row.bodyPart || 'Unknown';
                    bodyPartCounts[part] = (bodyPartCounts[part] || 0) + 1;
                });
                
                const topBodyPart = Object.entries(bodyPartCounts)
                    .sort((a, b) => b[1] - a[1])[0];
                
                if (topBodyPart && topBodyPart[1] > 3) {
                    recommendations.push({
                        priority: 'Medium',
                        title: `Ergonomic Assessment for ${topBodyPart[0]} Injuries`,
                        description: `Conduct comprehensive ergonomic assessments and implement engineering controls to reduce ${topBodyPart[0]} injuries, which represent ${((topBodyPart[1] / injuryData.length) * 100).toFixed(0)}% of all cases.`
                    });
                }
            }
            
            if (reportType === 'nearmiss' || reportType === 'combined' || reportType === 'executive') {
                // Near miss recommendations
                const nearMissData = state.nearMiss.filteredData;
                
                // High risk locations
                const locationRisks = {};
                nearMissData.forEach(row => {
                    const location = row.location || 'Unknown';
                    const risk = parseFloat(row.risk) || 0;
                    if (!locationRisks[location]) {
                        locationRisks[location] = { total: 0, count: 0 };
                    }
                    locationRisks[location].total += risk;
                    locationRisks[location].count++;
                });
                
                const highRiskLocation = Object.entries(locationRisks)
                    .map(([location, data]) => ({
                        location,
                        avgRisk: data.count > 0 ? data.total / data.count : 0,
                        count: data.count
                    }))
                    .sort((a, b) => b.avgRisk - a.avgRisk)[0];
                
                if (highRiskLocation && highRiskLocation.avgRisk > 6) {
                    recommendations.push({
                        priority: 'High',
                        title: `Safety Intervention at ${highRiskLocation.location}`,
                        description: `This location has an average risk score of ${highRiskLocation.avgRisk.toFixed(1)} across ${highRiskLocation.count} near misses. Implement immediate hazard controls and enhanced monitoring.`
                    });
                }
            }
            
            // General recommendations
            recommendations.push({
                priority: 'Medium',
                title: 'Enhance Safety Training Programs',
                description: 'Develop targeted safety training modules based on identified trends. Include hands-on demonstrations and competency verification for high-risk tasks.'
            });
            
            recommendations.push({
                priority: 'Low',
                title: 'Improve Data Quality',
                description: 'Standardize incident reporting procedures to ensure consistent data capture. Implement quality checks for description completeness and accuracy.'
            });
            
            return recommendations;
        }
        
        function generatePredictions() {
            const predictions = [];
            
            // Trend-based predictions
            const injuryTrend = calculateTrend(state.injury.filteredData);
            const nearMissTrend = calculateTrend(state.nearMiss.filteredData);
            
            if (injuryTrend > 0) {
                predictions.push(`Based on current trends, injury rates are projected to increase by ${(injuryTrend * 100).toFixed(0)}% over the next quarter without intervention.`);
            } else {
                predictions.push(`Current safety initiatives are projected to reduce injury rates by ${Math.abs(injuryTrend * 100).toFixed(0)}% in the next quarter.`);
            }
            
            // Risk-based predictions
            const highRiskNearMisses = state.nearMiss.filteredData.filter(r => parseFloat(r.risk) >= 7).length;
            if (highRiskNearMisses > 10) {
                predictions.push(`${highRiskNearMisses} high-risk near misses indicate potential for ${Math.floor(highRiskNearMisses * 0.1)} serious injuries if not addressed within 30 days.`);
            }
            
            // Seasonal predictions
            const currentMonth = new Date().getMonth();
            if (currentMonth >= 9 || currentMonth <= 2) { // Oct-Feb
                predictions.push('Historical data suggests 15-20% increase in slip/trip/fall incidents during winter months. Proactive measures recommended.');
            }
            
            // Site-specific predictions
            const siteRisks = {};
            state.injury.filteredData.forEach(row => {
                const site = row.site || 'Unknown';
                siteRisks[site] = (siteRisks[site] || 0) + 1;
            });
            
            const highestRiskSite = Object.entries(siteRisks)
                .sort((a, b) => b[1] - a[1])[0];
            
            if (highestRiskSite && highestRiskSite[1] > 5) {
                predictions.push(`${highestRiskSite[0]} shows elevated risk patterns and may experience ${Math.ceil(highestRiskSite[1] * 0.3)} additional incidents next month without targeted intervention.`);
            }
            
            return predictions;
        }
        
        function calculateTrend(data) {
            // Simple linear regression for trend
            const monthlyData = {};
            data.forEach(row => {
                if (row.parsedDate) {
                    const monthIndex = (row.parsedDate.getFullYear() - 2024) * 12 + row.parsedDate.getMonth();
                    monthlyData[monthIndex] = (monthlyData[monthIndex] || 0) + 1;
                }
            });
            
            const months = Object.keys(monthlyData).map(Number).sort((a, b) => a - b);
            if (months.length < 2) return 0;
            
            // Calculate slope
            const n = months.length;
            const sumX = months.reduce((a, b) => a + b, 0);
            const sumY = months.reduce((m, i) => m + monthlyData[i], 0);
            const sumXY = months.reduce((sum, x) => sum + x * monthlyData[x], 0);
            const sumX2 = months.reduce((sum, x) => sum + x * x, 0);
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            return slope / (sumY / n); // Normalized slope
        }
        
        function getReportPeriod() {
            const dates = [
                ...state.injury.filteredData.map(r => r.parsedDate),
                ...state.nearMiss.filteredData.map(r => r.parsedDate)
            ].filter(d => d && !isNaN(d));
            
            if (dates.length === 0) return 'No date range available';
            
            const minDate = new Date(Math.min(...dates));
            const maxDate = new Date(Math.max(...dates));
            
            return `${minDate.toLocaleDateString()} - ${maxDate.toLocaleDateString()}`;
        }
        
        function getCurrentUser() {
            return 'Safety Analytics User';
        }
        
        function addToReportHistory(reportType) {
            const historyContainer = document.getElementById('reportHistory');
            const timestamp = new Date().toLocaleString();
            
            const historyItem = document.createElement('div');
            historyItem.style.cssText = 'padding: 1rem; border-bottom: 1px solid var(--bg-secondary);';
            historyItem.innerHTML = `
                <strong>${reportType} Report</strong><br>
                <span style="color: var(--text-secondary); font-size: 0.9rem;">
                    Generated on ${timestamp}<br>
                    Records included: ${state.injury.filteredData.length + state.nearMiss.filteredData.length}
                </span>
            `;
            
            if (historyContainer.children[0]?.textContent.includes('No reports')) {
                historyContainer.innerHTML = '';
            }
            
            historyContainer.insertBefore(historyItem, historyContainer.firstChild);
            
            // Keep only last 10 reports
            while (historyContainer.children.length > 10) {
                historyContainer.removeChild(historyContainer.lastChild);
            }
        }

        // Timeline Functions
        function updateInjuryTimeline() {
            updateTimeline(state.injury.filteredData, 'injuryTimelineContent', 'injury');
        }

        function updateNearMissTimeline() {
            updateTimeline(state.nearMiss.filteredData, 'nearMissTimelineContent', 'nearmiss');
        }

        function updateTimeline(data, elementId, type) {
            const container = document.getElementById(elementId);
            if (!container) return;
            
            // Sort data by date (newest first)
            const sortedData = [...data].sort((a, b) => {
                const dateA = a.parsedDate || new Date(0);
                const dateB = b.parsedDate || new Date(0);
                return dateB - dateA;
            });
            
            if (sortedData.length === 0) {
                container.innerHTML = '<p style="text-align: center; padding: 2rem;">No data to display in timeline.</p>';
                return;
            }
            
            // Paginate timeline
            const currentPage = type === 'injury' ? state.injury.timelinePage : state.nearMiss.timelinePage;
            const itemsPerPage = 10;
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = Math.min(startIndex + itemsPerPage, sortedData.length);
            const pageData = sortedData.slice(startIndex, endIndex);
            
            // Update pagination info
            const totalPages = Math.ceil(sortedData.length / itemsPerPage);
            document.getElementById(`${type}TimelinePageInfo`).textContent = `Page ${currentPage} of ${totalPages}`;
            
            // Generate timeline HTML
            container.innerHTML = pageData.map((incident, index) => {
                const date = incident.parsedDate ? 
                    incident.parsedDate.toLocaleDateString('en-US', { 
                        year: 'numeric', 
                        month: 'long', 
                        day: 'numeric' 
                    }) : 'Date Unknown';
                
                const severityClass = getSeverityClass(incident.severity);
                const isInjury = type === 'injury';
                
                return `
                    <div class="timeline-item" style="animation-delay: ${index * 0.1}s;">
                        <div class="timeline-date">${date}</div>
                        <div class="timeline-content">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.5rem;">
                                <strong>${incident.case_number || incident.incident_id}</strong>
                                <span class="badge badge-${severityClass}">Severity ${incident.severity}</span>
                            </div>
                            <div style="color: var(--text-secondary); font-size: 0.9rem;">
                                <strong>Site:</strong> ${incident.site || 'Unknown'}<br>
                                ${isInjury ? 
                                    `<strong>Body Part:</strong> ${incident.bodyPart || 'Unknown'}<br>
                                     <strong>Recordable:</strong> ${incident.recordable === 1 ? 'Yes' : 'No'}<br>
                                     ${incident.total_dafw_days > 0 ? `<strong>DAFW Days:</strong> ${incident.total_dafw_days}<br>` : ''}` :
                                    `<strong>Location:</strong> ${incident.location || 'Unknown'}<br>
                                     <strong>Risk Score:</strong> ${incident.risk || 'N/A'}<br>
                                     <strong>Impact:</strong> ${incident.primaryImpact || 'Unknown'}<br>`
                                }
                                <strong>Description:</strong> ${(incident.description || 'No description').substring(0, 150)}${incident.description?.length > 150 ? '...' : ''}
                            </div>
                            <div style="margin-top: 0.5rem;">
                                <button class="btn btn-sm btn-outline" onclick="viewDetails('${type}', '${incident.case_number || incident.incident_id}')">
                                    View Details
                                </button>
                                ${incident.incident_url ? 
                                    `<a href="${incident.incident_url}" target="_blank" class="austin-link" style="margin-left: 0.5rem;">View in EHS System</a>` : 
                                    ''
                                }
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function changeTimelinePage(type, direction) {
            const data = type === 'injury' ? state.injury.filteredData : state.nearMiss.filteredData;
            const totalPages = Math.ceil(data.length / 10);
            
            if (type === 'injury') {
                state.injury.timelinePage += direction;
                if (state.injury.timelinePage < 1) state.injury.timelinePage = 1;
                if (state.injury.timelinePage > totalPages) state.injury.timelinePage = totalPages;
                updateInjuryTimeline();
            } else {
                state.nearMiss.timelinePage += direction;
                if (state.nearMiss.timelinePage < 1) state.nearMiss.timelinePage = 1;
                if (state.nearMiss.timelinePage > totalPages) state.nearMiss.timelinePage = totalPages;
                updateNearMissTimeline();
            }
        }

        // Advanced Analytics Functions
        function updateInjuryAdvancedAnalytics() {
            if (state.injury.filteredData.length === 0) {
                showStatus('No injury data loaded for advanced analytics', 'info');
                return;
            }
            
            // Update Recordable Rate Trend
            const recordableChart = state.injury.charts.injuryRecordableRateTrendChart;
            if (recordableChart) {
                updateRecordableRateTrendAnalysis(recordableChart);
            }
            
            // Update Body Part Heat Map
            const heatMapChart = state.injury.charts.injuryBodyPartHeatMapChart;
            if (heatMapChart) {
                updateBodyPartHeatMapAnalysis(heatMapChart);
            }
            
            // Update Root Cause by Site
            const rootCauseChart = state.injury.charts.injuryRootCauseBySiteChart;
            if (rootCauseChart) {
                updateRootCauseBySiteAnalysis(rootCauseChart);
            }
            
            // Update DAFW Distribution
            const dafwChart = state.injury.charts.injuryDAFWDistributionChart;
            if (dafwChart) {
                updateDAFWDistributionAnalysis(dafwChart);
            }
        }

        function updateNearMissAdvancedAnalytics() {
            if (state.nearMiss.filteredData.length === 0) {
                showStatus('No near miss data loaded for advanced analytics', 'info');
                return;
            }
            
            // Update Risk Trend
            const riskTrendChart = state.nearMiss.charts.nearMissRiskTrendChart;
            if (riskTrendChart) {
                updateNearMissRiskTrendAnalysis(riskTrendChart);
            }
            
            // Update Impact Analysis
            const impactChart = state.nearMiss.charts.nearMissImpactAnalysisChart;
            if (impactChart) {
                updateNearMissImpactAnalysis(impactChart);
            }
            
            // Update Location Risk
            const locationChart = state.nearMiss.charts.nearMissLocationRiskChart;
            if (locationChart) {
                updateNearMissLocationRiskAnalysis(locationChart);
            }
            
            // Update Process Risk
            const processChart = state.nearMiss.charts.nearMissProcessRiskChart;
            if (processChart) {
                updateNearMissProcessRiskAnalysis(processChart);
            }
        }

        function updateRecordableRateTrendAnalysis(chart) {
            const monthlyData = {};
            
            state.injury.filteredData.forEach(row => {
                if (row.parsedDate && !isNaN(row.parsedDate)) {
                    const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
                    if (!monthlyData[monthKey]) {
                        monthlyData[monthKey] = { total: 0, recordable: 0 };
                    }
                    monthlyData[monthKey].total++;
                    if (row.recordable === 1) {
                        monthlyData[monthKey].recordable++;
                    }
                }
            });
            
            const sortedMonths = Object.keys(monthlyData).sort();
            const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            
            chart.data = {
                labels: sortedMonths.map(m => {
                    const [year, month] = m.split('-');
                    return `${monthNames[parseInt(month)-1]} ${year}`;
                }),
                datasets: [{
                    label: 'Recordable Rate %',
                    data: sortedMonths.map(m => 
                        monthlyData[m].total > 0 ? 
                        ((monthlyData[m].recordable / monthlyData[m].total) * 100).toFixed(1) : 0
                    ),
                    borderColor: 'rgba(255, 87, 34, 1)',
                    backgroundColor: 'rgba(255, 87, 34, 0.1)',
                    tension: 0.3
                }]
            };
            chart.update();
        }

        function updateBodyPartHeatMapAnalysis(chart) {
            const bodyPartSeverity = {};
            
            state.injury.filteredData.forEach(row => {
                const part = row.bodyPart || 'Unknown';
                const severity = row.severity || 'Unknown';
                const key = `${part}-${severity}`;
                bodyPartSeverity[key] = (bodyPartSeverity[key] || 0) + 1;
            });
            
            // Create matrix data
            const bodyParts = [...new Set(state.injury.filteredData.map(r => r.bodyPart || 'Unknown'))]
                .sort()
                .slice(0, 10);
            const severities = ['A', 'B', 'C', 'D'];
            
            const datasets = severities.map((severity, sIndex) => ({
                label: `Severity ${severity}`,
                data: bodyParts.map(part => bodyPartSeverity[`${part}-${severity}`] || 0),
                backgroundColor: SEVERITY_COLORS[severity]
            }));
            
            chart.config.type = 'bar';
            chart.data = {
                labels: bodyParts.map(p => p.substring(0, 20) + (p.length > 20 ? '...' : '')),
                datasets: datasets
            };
            chart.options = getChartOptions('bar');
            chart.options.scales.x.stacked = true;
            chart.options.scales.y.stacked = true;
            chart.update();
        }

        function updateRootCauseBySiteAnalysis(chart) {
            const siteRootCause = {};
            
            state.injury.filteredData.forEach(row => {
                const site = row.site || 'Unknown';
                const cause = row.rootCause || 'Unknown';
                
                if (!siteRootCause[site]) {
                    siteRootCause[site] = {};
                }
                siteRootCause[site][cause] = (siteRootCause[site][cause] || 0) + 1;
            });
            
            // Get top sites
            const sites = Object.keys(siteRootCause).slice(0, 5);
            
            // Get all unique root causes
            const allCauses = [...new Set(
                Object.values(siteRootCause).flatMap(causes => Object.keys(causes))
            )].slice(0, 5);
            
            const datasets = allCauses.map((cause, index) => ({
                label: cause.substring(0, 30) + (cause.length > 30 ? '...' : ''),
                data: sites.map(site => siteRootCause[site][cause] || 0),
                backgroundColor: `rgba(${index * 50}, ${100 + index * 30}, ${200 - index * 30}, 0.8)`
            }));
            
            chart.config.type = 'bar';
            chart.data = {
                labels: sites,
                datasets: datasets
            };
            chart.options = getChartOptions('bar');
            chart.options.scales.x.stacked = true;
            chart.options.scales.y.stacked = true;
            chart.update();
        }

        function updateDAFWDistributionAnalysis(chart) {
            const dafwData = state.injury.filteredData
                .filter(r => r.total_dafw_days > 0)
                .map(r => ({
                    days: r.total_dafw_days,
                    severity: r.severity,
                    site: r.site
                }));
            
            if (dafwData.length === 0) {
                chart.data = { labels: [], datasets: [] };
                chart.update();
                return;
            }
            
            // Create histogram bins
            const bins = [
                { label: '1-3 days', min: 1, max: 3, count: 0 },
                { label: '4-7 days', min: 4, max: 7, count: 0 },
                { label: '8-14 days', min: 8, max: 14, count: 0 },
                { label: '15-30 days', min: 15, max: 30, count: 0 },
                { label: '31-60 days', min: 31, max: 60, count: 0 },
                { label: '60+ days', min: 61, max: Infinity, count: 0 }
            ];
            
            dafwData.forEach(item => {
                const bin = bins.find(b => item.days >= b.min && item.days <= b.max);
                if (bin) bin.count++;
            });
            
            chart.config.type = 'bar';
            chart.data = {
                labels: bins.map(b => b.label),
                datasets: [{
                    label: 'Number of Cases',
                    data: bins.map(b => b.count),
                    backgroundColor: bins.map((b, i) => {
                        const intensity = i / bins.length;
                        return `rgba(255, ${Math.floor(87 + intensity * 100)}, 34, 0.8)`;
                    }),
                    borderWidth: 1
                }]
            };
            chart.options = getChartOptions('bar');
            chart.update();
        }

        function updateNearMissRiskTrendAnalysis(chart) {
            const monthlyRisk = {};
            
            state.nearMiss.filteredData.forEach(row => {
                if (row.parsedDate && !isNaN(row.parsedDate)) {
                    const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
                    if (!monthlyRisk[monthKey]) {
                        monthlyRisk[monthKey] = { 
                            total: 0, 
                            count: 0, 
                            high: 0, 
                            medium: 0, 
                            low: 0 
                        };
                    }
                    
                    const risk = parseFloat(row.risk || calculateRiskScore(row));
                    if (!isNaN(risk)) {
                        monthlyRisk[monthKey].total += risk;
                        monthlyRisk[monthKey].count++;
                        
                        if (risk >= 7) monthlyRisk[monthKey].high++;
                        else if (risk >= 4) monthlyRisk[monthKey].medium++;
                        else monthlyRisk[monthKey].low++;
                    }
                }
            });
            
            const sortedMonths = Object.keys(monthlyRisk).sort();
            const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            
            chart.config.type = 'line';
            chart.data = {
                labels: sortedMonths.map(m => {
                    const [year, month] = m.split('-');
                    return `${monthNames[parseInt(month)-1]} ${year}`;
                }),
                datasets: [
                    {
                        label: 'Average Risk Score',
                        data: sortedMonths.map(m => 
                            monthlyRisk[m].count > 0 ? (monthlyRisk[m].total / monthlyRisk[m].count).toFixed(1) : 0
                        ),
                        borderColor: 'rgba(76, 175, 80, 1)',
                        backgroundColor: 'rgba(76, 175, 80, 0.1)',
                        tension: 0.3,
                        yAxisID: 'y'
                    },
                    {
                        label: 'High Risk Count',
                        data: sortedMonths.map(m => monthlyRisk[m].high),
                        borderColor: 'rgba(255, 87, 34, 1)',
                        backgroundColor: 'rgba(255, 87, 34, 0.1)',
                        tension: 0.3,
                        yAxisID: 'y1'
                    }
                ]
            };
            
            chart.options = getChartOptions('line');
            chart.options.scales.y1 = {
                type: 'linear',
                display: true,
                position: 'right',
                grid: {
                    drawOnChartArea: false
                },
                ticks: {
                    color: state.theme === 'dark' ? '#ffffff' : '#212121'
                }
            };
            chart.update();
        }

        function updateNearMissImpactAnalysis(chart) {
            const impactData = {};
            
            state.nearMiss.filteredData.forEach(row => {
                const impact = row.primaryImpact || 'Unknown';
                const severity = row.severity || 'Unknown';
                
                if (!impactData[impact]) {
                    impactData[impact] = {
                        total: 0,
                        severityA: 0,
                        severityB: 0,
                        severityC: 0,
                        severityD: 0,
                        avgRisk: 0,
                        riskSum: 0
                    };
                }
                
                impactData[impact].total++;
                if (severity === 'A') impactData[impact].severityA++;
                else if (severity === 'B') impactData[impact].severityB++;
                else if (severity === 'C') impactData[impact].severityC++;
                else if (severity === 'D') impactData[impact].severityD++;
                
                const risk = parseFloat(row.risk || calculateRiskScore(row));
                if (!isNaN(risk)) {
                    impactData[impact].riskSum += risk;
                }
            });
            
            // Calculate averages and sort by total
            const topImpacts = Object.entries(impactData)
                .map(([impact, data]) => ({
                    impact,
                    ...data,
                    avgRisk: data.total > 0 ? (data.riskSum / data.total).toFixed(1) : 0
                }))
                .sort((a, b) => b.total - a.total)
                .slice(0, 8);
            
            chart.config.type = 'bubble';
            chart.data = {
                datasets: topImpacts.map((impact, index) => ({
                    label: impact.impact,
                    data: [{
                        x: index,
                        y: parseFloat(impact.avgRisk),
                        r: Math.sqrt(impact.total) * 3
                    }],
                    backgroundColor: `rgba(${index * 30}, ${100 + index * 20}, ${200 - index * 20}, 0.6)`,
                    borderColor: `rgba(${index * 30}, ${100 + index * 20}, ${200 - index * 20}, 1)`,
                    borderWidth: 2
                }))
            };
            
            chart.options = getChartOptions('bubble');
            chart.options.scales.x = {
                type: 'category',
                labels: topImpacts.map(i => i.impact.substring(0, 15) + (i.impact.length > 15 ? '...' : '')),
                ticks: {
                    color: state.theme === 'dark' ? '#ffffff' : '#212121'
                }
            };
            chart.options.scales.y = {
                title: {
                    display: true,
                    text: 'Average Risk Score',
                    color: state.theme === 'dark' ? '#ffffff' : '#212121'
                },
                ticks: {
                    color: state.theme === 'dark' ? '#ffffff' : '#212121'
                }
            };
            chart.options.plugins.tooltip = {
                callbacks: {
                    label: function(context) {
                        const impact = topImpacts[context.dataIndex];
                        return [
                            `Impact: ${impact.impact}`,
                            `Avg Risk: ${impact.avgRisk}`,
                            `Total Incidents: ${impact.total}`,
                            `Severity A: ${impact.severityA}`,
                            `Severity B: ${impact.severityB}`
                        ];
                    }
                }
            };
            chart.update();
        }

        function updateNearMissLocationRiskAnalysis(chart) {
            const locationData = {};
            
            state.nearMiss.filteredData.forEach(row => {
                const location = row.location || 'Unknown';
                if (!locationData[location]) {
                    locationData[location] = {
                        total: 0,
                        riskSum: 0,
                        highRisk: 0,
                        repeatDays: new Set()
                    };
                }
                
                locationData[location].total++;
                const risk = parseFloat(row.risk || calculateRiskScore(row));
                if (!isNaN(risk)) {
                    locationData[location].riskSum += risk;
                    if (risk >= 7) locationData[location].highRisk++;
                }
                
                if (row.parsedDate) {
                    const dayKey = row.parsedDate.toISOString().split('T')[0];
                    locationData[location].repeatDays.add(dayKey);
                }
            });
            
            // Calculate metrics and sort
            const locationAnalysis = Object.entries(locationData)
                .map(([location, data]) => ({
                    location,
                    total: data.total,
                    avgRisk: data.total > 0 ? (data.riskSum / data.total).toFixed(1) : 0,
                    highRiskRate: data.total > 0 ? ((data.highRisk / data.total) * 100).toFixed(0) : 0,
                    frequency: data.repeatDays.size
                }))
                .sort((a, b) => b.avgRisk - a.avgRisk)
                .slice(0, 10);
            
            chart.config.type = 'radar';
            chart.data = {
                labels: locationAnalysis.map(l => l.location.substring(0, 20) + (l.location.length > 20 ? '...' : '')),
                datasets: [
                    {
                        label: 'Average Risk Score',
                        data: locationAnalysis.map(l => parseFloat(l.avgRisk)),
                        borderColor: 'rgba(255, 87, 34, 1)',
                        backgroundColor: 'rgba(255, 87, 34, 0.2)',
                        borderWidth: 2
                    },
                    {
                        label: 'High Risk Rate %',
                        data: locationAnalysis.map(l => parseFloat(l.highRiskRate) / 10), // Scale down for visibility
                        borderColor: 'rgba(76, 175, 80, 1)',
                        backgroundColor: 'rgba(76, 175, 80, 0.2)',
                        borderWidth: 2
                    }
                ]
            };
            
            chart.options = {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    r: {
                        beginAtZero: true,
                        ticks: {
                            color: state.theme === 'dark' ? '#ffffff' : '#212121'
                        },
                        grid: {
                            color: state.theme === 'dark' ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'
                        },
                        pointLabels: {
                            color: state.theme === 'dark' ? '#ffffff' : '#212121',
                            font: {
                                size: 10
                            }
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'bottom',
                        labels: {
                            color: state.theme === 'dark' ? '#ffffff' : '#212121'
                        }
                    }
                }
            };
            chart.update();
        }

        function updateNearMissProcessRiskAnalysis(chart) {
            const processData = {};
            
            state.nearMiss.filteredData.forEach(row => {
                const process = row.processPath || 'Unknown';
                if (!processData[process]) {
                    processData[process] = {
                        total: 0,
                        severitySum: 0,
                        likelihoodSum: 0,
                        riskSum: 0
                    };
                }
                
                processData[process].total++;
                
                // Convert severity to numeric
                const severityMap = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'Unknown': 1 };
                processData[process].severitySum += severityMap[row.severity] || 1;
                
                // Convert likelihood to numeric
                const likelihoodMap = { 
                    'Rare': 1, 
                    'Unlikely': 2, 
                    'Possible': 3, 
                    'Likely': 4, 
                    'Almost Certain': 5 
                };
                processData[process].likelihoodSum += likelihoodMap[row.standardized_likelihood] || 3;
                
                const risk = parseFloat(row.risk || calculateRiskScore(row));
                if (!isNaN(risk)) {
                    processData[process].riskSum += risk;
                }
            });
            
            // Calculate averages
            const processAnalysis = Object.entries(processData)
                .map(([process, data]) => ({
                    process,
                    total: data.total,
                    avgSeverity: data.total > 0 ? (data.severitySum / data.total).toFixed(1) : 0,
                    avgLikelihood: data.total > 0 ? (data.likelihoodSum / data.total).toFixed(1) : 0,
                    avgRisk: data.total > 0 ? (data.riskSum / data.total).toFixed(1) : 0
                }))
                .sort((a, b) => b.avgRisk - a.avgRisk)
                .slice(0, 8);
            
            chart.config.type = 'scatter';
            chart.data = {
                datasets: [{
                    label: 'Process Risk Analysis',
                    data: processAnalysis.map(p => ({
                        x: parseFloat(p.avgLikelihood),
                        y: parseFloat(p.avgSeverity),
                        label: p.process
                    })),
                    backgroundColor: processAnalysis.map(p => {
                        const risk = parseFloat(p.avgRisk);
                        if (risk >= 7) return 'rgba(255, 87, 34, 0.8)';
                        if (risk >= 4) return 'rgba(255, 193, 7, 0.8)';
                        return 'rgba(76, 175, 80, 0.8)';
                    }),
                    borderColor: processAnalysis.map(p => {
                        const risk = parseFloat(p.avgRisk);
                        if (risk >= 7) return 'rgba(255, 87, 34, 1)';
                        if (risk >= 4) return 'rgba(255, 193, 7, 1)';
                        return 'rgba(76, 175, 80, 1)';
                    }),
                    borderWidth: 2,
                    pointRadius: processAnalysis.map(p => Math.sqrt(p.total) * 3)
                }]
            };
            
            chart.options = getChartOptions('scatter');
            chart.options.scales.x = {
                title: {
                    display: true,
                    text: 'Average Likelihood',
                    color: state.theme === 'dark' ? '#ffffff' : '#212121'
                },
                min: 0,
                max: 5,
                ticks: {
                    color: state.theme === 'dark' ? '#ffffff' : '#212121',
                    callback: function(value) {
                        const labels = ['', 'Rare', 'Unlikely', 'Possible', 'Likely', 'Almost Certain'];
                        return labels[Math.round(value)] || '';
                    }
                }
            };
            chart.options.scales.y = {
                title: {
                    display: true,
                    text: 'Average Severity',
                    color: state.theme === 'dark' ? '#ffffff' : '#212121'
                },
                min: 0,
                max: 5,
                ticks: {
                    color: state.theme === 'dark' ? '#ffffff' : '#212121',
                    callback: function(value) {
                        const labels = ['', 'D', 'C', 'B', 'A', ''];
                        return labels[Math.round(value)] || '';
                    }
                },
                reverse: true
            };
            chart.options.plugins.tooltip = {
                callbacks: {
                    label: function(context) {
                        const p = processAnalysis[context.dataIndex];
                        return [
                            `Process: ${p.process}`,
                            `Avg Risk: ${p.avgRisk}`,
                            `Total Incidents: ${p.total}`,
                            `Avg Severity: ${p.avgSeverity}`,
                            `Avg Likelihood: ${p.avgLikelihood}`
                        ];
                    }
                }
            };
            chart.update();
        }

        // Combined Analytics Functions
        function updateCombinedAnalytics() {
            if (state.injury.rawData.length === 0 && state.nearMiss.rawData.length === 0) {
                showStatus('No data loaded for combined analytics', 'info');
                return;
            }
            
            // Update metrics
            const totalEvents = state.injury.filteredData.length + state.nearMiss.filteredData.length;
            document.getElementById('combinedTotal').textContent = totalEvents;
            
            const highRiskEvents = [
                ...state.injury.filteredData.filter(r => r.severity === 'A' || r.severity === 'B'),
                ...state.nearMiss.filteredData.filter(r => parseFloat(r.risk) >= 7)
            ].length;
            document.getElementById('combinedHighRisk').textContent = highRiskEvents;
            
            // Calculate trend
            const trend = calculateCombinedTrend();
            document.getElementById('combinedTrend').textContent = 
                trend > 0 ? `+${trend}%` : `${trend}%`;
            
            // Sites requiring focus
            const targetSites = identifyTargetSites();
            document.getElementById('combinedTargetSites').textContent = targetSites.length;
            
            // Update charts
            updateCombinedCharts();
            
            // Update risk matrix
            updateCombinedRiskMatrix();
            
            // Generate insights
            generateCombinedInsights();
        }

        function calculateCombinedTrend() {
            // Calculate month-over-month trend
            const allData = [...state.injury.filteredData, ...state.nearMiss.filteredData];
            const monthlyData = {};
            
            allData.forEach(row => {
                if (row.parsedDate) {
                    const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
                    monthlyData[monthKey] = (monthlyData[monthKey] || 0) + 1;
                }
            });
            
            const months = Object.keys(monthlyData).sort();
            if (months.length < 2) return 0;
            
            const lastMonth = monthlyData[months[months.length - 1]];
            const previousMonth = monthlyData[months[months.length - 2]];
            
            if (previousMonth === 0) return 0;
            return Math.round(((lastMonth - previousMonth) / previousMonth) * 100);
        }

        function identifyTargetSites() {
            const siteScores = {};
            
            // Score injuries
            state.injury.filteredData.forEach(row => {
                const site = row.site || 'Unknown';
                if (!siteScores[site]) siteScores[site] = 0;
                
                // Weight by severity
                if (row.severity === 'A') siteScores[site] += 5;
                else if (row.severity === 'B') siteScores[site] += 3;
                else if (row.severity === 'C') siteScores[site] += 2;
                else siteScores[site] += 1;
                
                // Add weight for recordable
                if (row.recordable === 1) siteScores[site] += 2;
            });
            
            // Score near misses
            state.nearMiss.filteredData.forEach(row => {
                const site = row.site || 'Unknown';
                if (!siteScores[site]) siteScores[site] = 0;
                
                const risk = parseFloat(row.risk || 0);
                siteScores[site] += risk / 10; // Normalize to injury scale
            });
            
            // Identify sites with scores above threshold
            const threshold = 10;
            return Object.entries(siteScores)
                .filter(([, score]) => score > threshold)
                .map(([site]) => site);
        }

        function updateCombinedCharts() {
            // Update trend chart
            const trendChart = Chart.getChart("combinedTrendChart");
            if (trendChart) {
                updateCombinedTrendChart(trendChart);
            }
            
            // Update site comparison
            const siteChart = Chart.getChart("combinedSiteChart");
            if (siteChart) {
                updateCombinedSiteChart(siteChart);
            }
            
            // Update severity analysis
            const severityChart = Chart.getChart("combinedSeverityChart");
            if (severityChart) {
                updateCombinedSeverityChart(severityChart);
            }
            
            // Update prevention effectiveness
            const preventionChart = Chart.getChart("combinedPreventionChart");
            if (preventionChart) {
                updatePreventionEffectivenessChart(preventionChart);
            }
        }

        function updateCombinedTrendChart(chart) {
            const monthlyData = {};
            
            // Process all data
            [...state.injury.filteredData, ...state.nearMiss.filteredData].forEach(row => {
                if (row.parsedDate && !isNaN(row.parsedDate)) {
                    const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
                    if (!monthlyData[monthKey]) {
                        monthlyData[monthKey] = { injury: 0, nearMiss: 0, total: 0 };
                    }
                    
                    if (row.case_number) {
                        monthlyData[monthKey].injury++;
                    } else {
                        monthlyData[monthKey].nearMiss++;
                    }
                    monthlyData[monthKey].total++;
                }
            });
            
            const sortedMonths = Object.keys(monthlyData).sort();
            const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            
            chart.data = {
                labels: sortedMonths.map(m => {
                    const [year, month] = m.split('-');
                    return `${monthNames[parseInt(month)-1]} ${year}`;
                }),
                datasets: [
                    {
                        label: 'Total Safety Events',
                        data: sortedMonths.map(m => monthlyData[m].total),
                        borderColor: 'rgba(76, 175, 80, 1)',
                        backgroundColor: 'rgba(76, 175, 80, 0.1)',
                        tension: 0.3,
                        borderWidth: 3
                    },
                    {
                        label: 'Injuries',
                        data: sortedMonths.map(m => monthlyData[m].injury),
                        borderColor: 'rgba(255, 87, 34, 1)',
                        backgroundColor: 'rgba(255, 87, 34, 0.1)',
                        tension: 0.3,
                        borderDash: [5, 5]
                    },
                    {
                        label: 'Near Misses',
                        data: sortedMonths.map(m => monthlyData[m].nearMiss),
                        borderColor: 'rgba(255, 193, 7, 1)',
                        backgroundColor: 'rgba(255, 193, 7, 0.1)',
                        tension: 0.3,
                        borderDash: [5, 5]
                    }
                ]
            };
            chart.update();
        }

        function updateCombinedSiteChart(chart) {
            const siteData = {};
            
            // Aggregate data by site
            state.injury.filteredData.forEach(row => {
                const site = row.site || 'Unknown';
                if (!siteData[site]) {
                    siteData[site] = { injury: 0, nearMiss: 0, score: 0 };
                }
                siteData[site].injury++;
                siteData[site].score += row.severity === 'A' ? 5 : 
                                       row.severity === 'B' ? 3 : 
                                       row.severity === 'C' ? 2 : 1;
            });
            
            state.nearMiss.filteredData.forEach(row => {
                const site = row.site || 'Unknown';
                if (!siteData[site]) {
                    siteData[site] = { injury: 0, nearMiss: 0, score: 0 };
                }
                siteData[site].nearMiss++;
                siteData[site].score += parseFloat(row.risk || 0) / 2;
            });
            
            // Sort by total score
            const sortedSites = Object.entries(siteData)
                .sort((a, b) => b[1].score - a[1].score)
                .slice(0, 10);
            
            chart.config.type = 'bar';
            chart.data = {
                labels: sortedSites.map(([site]) => site),
                datasets: [
                    {
                        label: 'Injuries',
                        data: sortedSites.map(([, data]) => data.injury),
                        backgroundColor: 'rgba(255, 87, 34, 0.8)',
                        stack: 'Stack 0'
                    },
                    {
                        label: 'Near Misses',
                        data: sortedSites.map(([, data]) => data.nearMiss),
                        backgroundColor: 'rgba(255, 193, 7, 0.8)',
                        stack: 'Stack 0'
                    },
                    {
                        label: 'Risk Score',
                        data: sortedSites.map(([, data]) => data.score.toFixed(1)),
                        backgroundColor: 'rgba(76, 175, 80, 0.8)',
                        type: 'line',
                        borderColor: 'rgba(76, 175, 80, 1)',
                        borderWidth: 2,
                        yAxisID: 'y1'
                    }
                ]
            };
            
            chart.options = getChartOptions('bar');
            chart.options.scales.y1 = {
                type: 'linear',
                display: true,
                position: 'right',
                grid: {
                    drawOnChartArea: false
                },
                ticks: {
                    color: state.theme === 'dark' ? '#ffffff' : '#212121'
                }
            };
            chart.update();
        }

        function updateCombinedSeverityChart(chart) {
            const severityData = {
                injury: { A: 0, B: 0, C: 0, D: 0 },
                nearMiss: { A: 0, B: 0, C: 0, D: 0 }
            };
            
            state.injury.filteredData.forEach(row => {
                if (row.severity && severityData.injury[row.severity] !== undefined) {
                    severityData.injury[row.severity]++;
                }
            });
            
            state.nearMiss.filteredData.forEach(row => {
                if (row.severity && severityData.nearMiss[row.severity] !== undefined) {
                    severityData.nearMiss[row.severity]++;
                }
            });
            
            chart.config.type = 'bar';
            chart.data = {
                labels: ['Severity A', 'Severity B', 'Severity C', 'Severity D'],
                datasets: [
                    {
                        label: 'Injuries',
                        data: ['A', 'B', 'C', 'D'].map(s => severityData.injury[s]),
                        backgroundColor: 'rgba(255, 87, 34, 0.8)',
                        borderColor: 'rgba(255, 87, 34, 1)',
                        borderWidth: 1
                    },
                    {
                        label: 'Near Misses',
                        data: ['A', 'B', 'C', 'D'].map(s => severityData.nearMiss[s]),
                        backgroundColor: 'rgba(255, 193, 7, 0.8)',
                        borderColor: 'rgba(255, 193, 7, 1)',
                        borderWidth: 1
                    }
                ]
            };
            chart.update();
        }

        function updatePreventionEffectivenessChart(chart) {
            // Calculate prevention effectiveness based on near miss to injury ratio
            const monthlyEffectiveness = {};
            
            [...state.injury.filteredData, ...state.nearMiss.filteredData].forEach(row => {
                if (row.parsedDate && !isNaN(row.parsedDate)) {
                    const monthKey = `${row.parsedDate.getFullYear()}-${String(row.parsedDate.getMonth() + 1).padStart(2, '0')}`;
                    if (!monthlyEffectiveness[monthKey]) {
                        monthlyEffectiveness[monthKey] = { injury: 0, nearMiss: 0 };
                    }
                    
                    if (row.case_number) {
                        monthlyEffectiveness[monthKey].injury++;
                    } else {
                        monthlyEffectiveness[monthKey].nearMiss++;
                    }
                }
            });
            
            const sortedMonths = Object.keys(monthlyEffectiveness).sort();
            const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            
            // Calculate ratios and moving average
            const ratios = sortedMonths.map(month => {
                const data = monthlyEffectiveness[month];
                return data.injury > 0 ? data.nearMiss / data.injury : data.nearMiss;
            });
            
            const movingAverage = ratios.map((_, index) => {
                const start = Math.max(0, index - 2);
                const end = index + 1;
                const subset = ratios.slice(start, end);
                return subset.reduce((a, b) => a + b, 0) / subset.length;
            });
            
            chart.config.type = 'line';
            chart.data = {
                labels: sortedMonths.map(m => {
                    const [year, month] = m.split('-');
                    return `${monthNames[parseInt(month)-1]} ${year}`;
                }),
                datasets: [
                    {
                        label: 'Near Miss to Injury Ratio',
                        data: ratios,
                        borderColor: 'rgba(76, 175, 80, 1)',
                        backgroundColor: 'rgba(76, 175, 80, 0.1)',
                        borderWidth: 2,
                        tension: 0.3
                    },
                    {
                        label: '3-Month Moving Average',
                        data: movingAverage,
                        borderColor: 'rgba(33, 150, 243, 1)',
                        backgroundColor: 'rgba(33, 150, 243, 0.1)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        tension: 0.3
                    },
                    {
                        label: 'Target Ratio (10:1)',
                        data: sortedMonths.map(() => 10),
                        borderColor: 'rgba(255, 87, 34, 1)',
                        borderWidth: 2,
                        borderDash: [10, 5],
                        pointRadius: 0,
                        fill: false
                    }
                ]
            };
            
            chart.options = getChartOptions('line');
            chart.options.scales.y.title = {
                display: true,
                text: 'Near Miss to Injury Ratio',
                color: state.theme === 'dark' ? '#ffffff' : '#212121'
            };
            chart.update();
        }

        function updateCombinedRiskMatrix() {
            const allData = [...state.injury.filteredData, ...state.nearMiss.filteredData];
            updateRiskMatrix(allData, 'combinedRiskMatrix');
        }

        function generateCombinedInsights() {
            const insights = [];
            const container = document.getElementById('combinedInsights');
            
            // Near miss to injury ratio
            const nmRatio = state.injury.filteredData.length > 0 ? 
                (state.nearMiss.filteredData.length / state.injury.filteredData.length).toFixed(1) : 
                state.nearMiss.filteredData.length;
            
            insights.push(`<strong>Near Miss Reporting Culture:</strong> Current ratio is ${nmRatio}:1. ${
                nmRatio >= 10 ? 'Excellent proactive reporting culture.' : 
                nmRatio >= 5 ? 'Good reporting, but room for improvement.' : 
                'Low near miss reporting indicates potential underreporting.'
            }`);
            
            // Severity correlation
            const injurySevA = state.injury.filteredData.filter(r => r.severity === 'A').length;
            const nmSevA = state.nearMiss.filteredData.filter(r => r.severity === 'A').length;
            
            if (injurySevA > 0 && nmSevA > 0) {
                insights.push(`<strong>Critical Risk Pattern:</strong> ${injurySevA} Severity A injuries and ${nmSevA} Severity A near misses indicate systemic high-risk exposure requiring immediate intervention.`);
            }
            
            // Location correlation
            const injuryLocations = {};
            const nmLocations = {};
            
            state.injury.filteredData.forEach(row => {
                const loc = row.initial_info_location_event || row.site || 'Unknown';
                injuryLocations[loc] = (injuryLocations[loc] || 0) + 1;
            });
            
            state.nearMiss.filteredData.forEach(row => {
                const loc = row.location || row.site || 'Unknown';
                nmLocations[loc] = (nmLocations[loc] || 0) + 1;
            });
            
            // Find common high-risk locations
            const commonLocations = Object.keys(injuryLocations).filter(loc => 
                injuryLocations[loc] >= 2 && nmLocations[loc] >= 3
            );
            
            if (commonLocations.length > 0) {
                insights.push(`<strong>High-Risk Locations:</strong> ${commonLocations.join(', ')} show both injuries and multiple near misses, indicating persistent hazards.`);
            }
            
            // Process path analysis
            const processCorrelation = analyzeProcessCorrelation();
            if (processCorrelation.length > 0) {
                insights.push(`<strong>Process Risk Areas:</strong> ${processCorrelation.join(', ')} show elevated risk across both injuries and near misses.`);
            }
            
            // Trend analysis
            const injuryTrend = calculateTrend(state.injury.filteredData);
            const nmTrend = calculateTrend(state.nearMiss.filteredData);
            
            if (injuryTrend < 0 && nmTrend > 0) {
                insights.push(`<strong>Positive Safety Culture:</strong> Injuries decreasing (${(injuryTrend * 100).toFixed(0)}%) while near miss reporting increasing (${(nmTrend * 100).toFixed(0)}%), indicating improved hazard awareness.`);
            } else if (injuryTrend > 0 && nmTrend < 0) {
                insights.push(`<strong>Warning:</strong> Injuries increasing (${(injuryTrend * 100).toFixed(0)}%) while near miss reporting decreasing (${(nmTrend * 100).toFixed(0)}%). This pattern suggests deteriorating safety culture.`);
            }
            
            // Render insights
            container.innerHTML = insights.map(insight => `
                <div style="padding: 1rem; margin-bottom: 1rem; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid var(--primary);">
                    <p style="margin: 0;">${insight}</p>
                </div>
            `).join('');
        }

        function analyzeProcessCorrelation() {
            const processRisk = {};
            
            state.injury.filteredData.forEach(row => {
                const process = row.processPath || 'Unknown';
                if (!processRisk[process]) processRisk[process] = { injury: 0, nearMiss: 0 };
                processRisk[process].injury++;
            });
            
            state.nearMiss.filteredData.forEach(row => {
                const process = row.processPath || 'Unknown';
                if (!processRisk[process]) processRisk[process] = { injury: 0, nearMiss: 0 };
                processRisk[process].nearMiss++;
            });
            
            return Object.entries(processRisk)
                .filter(([, data]) => data.injury >= 2 && data.nearMiss >= 5)
                .map(([process]) => process)
                .slice(0, 3);
        }

        // Action Items Functions
        function updateActionItems() {
            generateImmediateActions();
            generateShortTermActions();
            generateLongTermActions();
        }

        function generateImmediateActions() {
            const container = document.getElementById('immediateActions');
            const actions = [];
            
            // Check for critical injuries
            const criticalInjuries = state.injury.filteredData.filter(r => r.severity === 'A');
            if (criticalInjuries.length > 0) {
                actions.push({
                    icon: '🚨',
                    title: 'Address Critical Injuries',
                    description: `${criticalInjuries.length} Severity A injuries require immediate investigation and corrective actions.`,
                    sites: [...new Set(criticalInjuries.map(r => r.site))].filter(Boolean)
                });
            }
            
            // Check for high-risk near misses
            const highRiskNM = state.nearMiss.filteredData.filter(r => parseFloat(r.risk) >= 8);
            if (highRiskNM.length > 0) {
                actions.push({
                    icon: '⚠️',
                    title: 'Mitigate High-Risk Near Misses',
                    description: `${highRiskNM.length} near misses with risk score ≥8 require immediate controls.`,
                    locations: [...new Set(highRiskNM.map(r => r.location))].filter(Boolean).slice(0, 3)
                });
            }
            
            // Check for repeat locations
            const locationCounts = {};
            [...state.injury.filteredData, ...state.nearMiss.filteredData].forEach(row => {
                const loc = row.location || row.initial_info_location_event || 'Unknown';
                locationCounts[loc] = (locationCounts[loc] || 0) + 1;
            });
            
            const dangerousLocations = Object.entries(locationCounts)
                .filter(([loc, count]) => count >= 5 && loc !== 'Unknown')
                .sort((a, b) => b[1] - a[1]);
            
            if (dangerousLocations.length > 0) {
                actions.push({
                    icon: '📍',
                    title: 'Secure High-Risk Locations',
                    description: `${dangerousLocations[0][0]} has ${dangerousLocations[0][1]} incidents. Conduct immediate hazard assessment.`
                });
            }
            
            renderActions(container, actions, 'immediate');
        }

        function generateShortTermActions() {
            const container = document.getElementById('shortTermActions');
            const actions = [];
            
            // Training needs based on body parts
            const bodyPartCounts = {};
            state.injury.filteredData.forEach(row => {
                const part = row.bodyPart || 'Unknown';
                bodyPartCounts[part] = (bodyPartCounts[part] || 0) + 1;
            });
            
            const topBodyPart = Object.entries(bodyPartCounts)
                .sort((a, b) => b[1] - a[1])[0];
            
            if (topBodyPart && topBodyPart[1] >= 3) {
                actions.push({
                    icon: '🎓',
                    title: `Ergonomic Training for ${topBodyPart[0]} Protection`,
                    description: `${topBodyPart[1]} injuries involving ${topBodyPart[0]}. Implement targeted training within 30 days.`
                });
            }
            
            // Process improvements
            const processIssues = {};
            [...state.injury.filteredData, ...state.nearMiss.filteredData].forEach(row => {
                const process = row.processPath || 'Unknown';
                processIssues[process] = (processIssues[process] || 0) + 1;
            });
            
            const topProcess = Object.entries(processIssues)
                .filter(([proc]) => proc !== 'Unknown')
                .sort((a, b) => b[1] - a[1])[0];
            
            if (topProcess && topProcess[1] >= 5) {
                actions.push({
                    icon: '🔧',
                    title: `Process Improvement: ${topProcess[0]}`,
                    description: `${topProcess[1]} incidents in this process. Conduct process safety review and implement controls.`
                });
            }
            
            // Site-specific actions
            const siteScores = calculateSiteRiskScores();
            const highRiskSites = Object.entries(siteScores)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 2);
            
            highRiskSites.forEach(([site, score]) => {
                if (score > 10) {
                    actions.push({
                        icon: '🏭',
                        title: `Site Safety Campaign: ${site}`,
                        description: `Risk score of ${score.toFixed(1)}. Launch targeted safety campaign and increase inspections.`
                    });
                }
            });
            
            renderActions(container, actions, 'short-term');
        }

        function generateLongTermActions() {
            const container = document.getElementById('longTermActions');
            const actions = [];
            
            // Culture improvements
            const nmRatio = state.injury.filteredData.length > 0 ? 
                (state.nearMiss.filteredData.length / state.injury.filteredData.length).toFixed(1) : 
                state.nearMiss.filteredData.length;
            
            if (nmRatio < 10) {
                actions.push({
                    icon: '🌟',
                    title: 'Enhance Safety Culture Program',
                    description: `Current near miss ratio is ${nmRatio}:1. Implement recognition program to achieve 10:1 target.`
                });
            }
            
            // Technology solutions
            const repeatPatterns = identifyRepeatPatterns();
            if (repeatPatterns.length > 0) {
                actions.push({
                    icon: '💡',
                    title: 'Implement Predictive Analytics',
                    description: 'Recurring patterns identified. Deploy IoT sensors and AI-based risk prediction in high-risk areas.'
                });
            }
            
            // Engineering controls
            const engineeringNeeds = identifyEngineeringOpportunities();
            if (engineeringNeeds.length > 0) {
                actions.push({
                    icon: '🏗️',
                    title: 'Engineering Control Implementation',
                    description: `${engineeringNeeds.length} areas identified for permanent hazard elimination through engineering controls.`
                });
            }
            
            // Behavioral safety
            actions.push({
                icon: '👥',
                title: 'Behavioral-Based Safety Program',
                description: 'Establish peer observation program with monthly safety conversations and feedback loops.'
            });
            
            renderActions(container, actions, 'long-term');
        }

        function calculateSiteRiskScores() {
            const scores = {};
            
            state.injury.filteredData.forEach(row => {
                const site = row.site || 'Unknown';
                if (!scores[site]) scores[site] = 0;
                
                // Weight by severity and recordability
                const severityWeight = row.severity === 'A' ? 5 : 
                                     row.severity === 'B' ? 3 : 
                                     row.severity === 'C' ? 2 : 1;
                scores[site] += severityWeight;
                if (row.recordable === 1) scores[site] += 2;
            });
            
            state.nearMiss.filteredData.forEach(row => {
                const site = row.site || 'Unknown';
                if (!scores[site]) scores[site] = 0;
                scores[site] += parseFloat(row.risk || 0) / 5;
            });
            
            return scores;
        }

        function identifyRepeatPatterns() {
            const patterns = [];
            
            // Time-based patterns
            const hourPatterns = {};
            [...state.injury.filteredData, ...state.nearMiss.filteredData].forEach(row => {
                if (row.parsedDate) {
                    const hour = row.parsedDate.getHours();
                    hourPatterns[hour] = (hourPatterns[hour] || 0) + 1;
                }
            });
            
            // Find peak hours
            const peakHours = Object.entries(hourPatterns)
                .filter(([, count]) => count >= 5)
                .map(([hour]) => parseInt(hour));
            
            if (peakHours.length > 0) {
                patterns.push('time-based');
            }
            
            // Location patterns
            const locationPatterns = {};
            [...state.injury.filteredData, ...state.nearMiss.filteredData].forEach(row => {
                const loc = row.location || row.initial_info_location_event || 'Unknown';
                locationPatterns[loc] = (locationPatterns[loc] || 0) + 1;
            });
            
            const repeatLocations = Object.values(locationPatterns).filter(count => count >= 5).length;
            if (repeatLocations > 2) {
                patterns.push('location-based');
            }
            
            return patterns;
        }

        function identifyEngineeringOpportunities() {
            const opportunities = [];
            
            // Check for manual handling injuries
            const manualHandling = state.injury.filteredData.filter(r => 
                r.bodyPart?.toLowerCase().includes('back') || 
                r.rootCause?.toLowerCase().includes('lift') ||
                r.rootCause?.toLowerCase().includes('manual')
            ).length;
            
            if (manualHandling >= 3) {
                opportunities.push('Automated material handling systems');
            }
            
            // Check for slip/trip/fall
            const slipTripFall = [...state.injury.filteredData, ...state.nearMiss.filteredData].filter(r => 
                r.type?.toLowerCase().includes('slip') ||
                r.type?.toLowerCase().includes('trip') ||
                r.type?.toLowerCase().includes('fall') ||
                r.primaryImpact?.toLowerCase().includes('fall')
            ).length;
            
            if (slipTripFall >= 5) {
                opportunities.push('Anti-slip flooring and improved lighting');
            }
            
            // Check for equipment-related incidents
            const equipmentIncidents = [...state.injury.filteredData, ...state.nearMiss.filteredData].filter(r => 
                r.rootCause?.toLowerCase().includes('equipment') ||
                r.contributingFactor?.toLowerCase().includes('equipment')
            ).length;
            
            if (equipmentIncidents >= 4) {
                opportunities.push('Equipment guarding and interlocks');
            }
            
            return opportunities;
        }

        function renderActions(container, actions, type) {
            if (actions.length === 0) {
                container.innerHTML = `
                    <li class="action-item">
                        <span class="action-icon ${type}">✓</span>
                        <div style="flex: 1;">
                            <strong>No ${type.replace('-', ' ')} actions required</strong>
                            <p style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 0.25rem;">
                                Continue monitoring and maintaining current safety performance
                            </p>
                        </div>
                    </li>
                `;
                return;
            }
            
            container.innerHTML = actions.map(action => `
                <li class="action-item">
                    <span class="action-icon ${type}">${action.icon}</span>
                    <div style="flex: 1;">
                        <strong>${action.title}</strong>
                        <p style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 0.25rem;">
                            ${action.description}
                        </p>
                        ${action.sites ? `<p style="font-size: 0.85rem; color: var(--primary); margin-top: 0.25rem;">Sites: ${action.sites.join(', ')}</p>` : ''}
                        ${action.locations ? `<p style="font-size: 0.85rem; color: var(--primary); margin-top: 0.25rem;">Locations: ${action.locations.join(', ')}</p>` : ''}
                    </div>
                    <button class="btn btn-sm btn-outline" onclick="markActionComplete(this)">
                        Mark Complete
                    </button>
                </li>
            `).join('');
        }

        function markActionComplete(button) {
            const actionItem = button.closest('.action-item');
            actionItem.style.opacity = '0.5';
            actionItem.style.textDecoration = 'line-through';
            button.textContent = 'Completed';
            button.disabled = true;
            showStatus('Action marked as complete', 'success');
        }

        function addNewAction() {
            // This would open a modal to add custom action items
            showStatus('Action creation feature coming soon', 'info');
        }

        // Export Functions
        function exportInjuryData() {
            exportToExcel('injury');
        }

        function exportNearMissData() {
            exportToExcel('nearmiss');
        }

        function exportToExcel(type) {
            let data, filename;
            
            if (type === 'injury') {
                data = state.injury.filteredData;
                filename = `Injury_Analysis_${new Date().toISOString().split('T')[0]}.xlsx`;
            } else if (type === 'nearmiss') {
                data = state.nearMiss.filteredData;
                filename = `NearMiss_Analysis_${new Date().toISOString().split('T')[0]}.xlsx`;
            } else if (type === 'all') {
                // Export both datasets
                exportAllData();
                return;
            }
            
            if (data.length === 0) {
                showStatus('No data to export', 'error');
                return;
            }
            
            // Create workbook
            const wb = XLSX.utils.book_new();
            
            // Main data sheet
            const ws = XLSX.utils.json_to_sheet(data);
            XLSX.utils.book_append_sheet(wb, ws, 'Data');
            
            // Summary sheet
            const summary = createSummaryData(type);
            const summaryWs = XLSX.utils.json_to_sheet(summary);
            XLSX.utils.book_append_sheet(wb, summaryWs, 'Summary');
            
            // Save file
            XLSX.writeFile(wb, filename);
            showStatus(`Exported ${data.length} records to Excel`, 'success');
        }

        function exportAllData() {
            const wb = XLSX.utils.book_new();
            
            // Injury data
            if (state.injury.filteredData.length > 0) {
                const injuryWs = XLSX.utils.json_to_sheet(state.injury.filteredData);
                XLSX.utils.book_append_sheet(wb, injuryWs, 'Injuries');
            }
            
            // Near miss data
            if (state.nearMiss.filteredData.length > 0) {
                const nearMissWs = XLSX.utils.json_to_sheet(state.nearMiss.filteredData);
                XLSX.utils.book_append_sheet(wb, nearMissWs, 'Near Misses');
            }
            
            // Combined summary
            const summary = createCombinedSummary();
            const summaryWs = XLSX.utils.json_to_sheet(summary);
            XLSX.utils.book_append_sheet(wb, summaryWs, 'Summary');
            
            // Save file
            const filename = `Safety_Analysis_Complete_${new Date().toISOString().split('T')[0]}.xlsx`;
            XLSX.writeFile(wb, filename);
            showStatus('Exported all data to Excel', 'success');
        }

        function createSummaryData(type) {
            const data = type === 'injury' ? state.injury.filteredData : state.nearMiss.filteredData;
            
            const summary = [
                { Metric: 'Total Records', Value: data.length },
                { Metric: 'Date Range', Value: getReportPeriod() },
                { Metric: 'Sites Affected', Value: [...new Set(data.map(r => r.site))].filter(Boolean).length }
            ];
            
            if (type === 'injury') {
                summary.push(
                    { Metric: 'Recordable Cases', Value: data.filter(r => r.recordable === 1).length },
                    { Metric: 'Lost Time Cases', Value: data.filter(r => r.total_dafw_days > 0).length },
                    { Metric: 'Total DAFW Days', Value: data.reduce((sum, r) => sum + (r.total_dafw_days || 0), 0) },
                    { Metric: 'OTR Incidents', Value: data.filter(r => r.otr === 'yes').length }
                );
            } else {
                const avgRisk = data.length > 0 ? 
                    (data.reduce((sum, r) => sum + parseFloat(r.risk || 0), 0) / data.length).toFixed(1) : 0;
                summary.push(
                    { Metric: 'Average Risk Score', Value: avgRisk },
                    { Metric: 'High Risk (≥7)', Value: data.filter(r => parseFloat(r.risk) >= 7).length },
                    { Metric: 'Critical Severity (A)', Value: data.filter(r => r.severity === 'A').length }
                );
            }
            
            // Add severity breakdown
            ['A', 'B', 'C', 'D'].forEach(severity => {
                summary.push({
                    Metric: `Severity ${severity} Count`,
                    Value: data.filter(r => r.severity === severity).length
                });
            });
            
            return summary;
        }

        function createCombinedSummary() {
            return [
                { Metric: 'Total Injuries', Value: state.injury.filteredData.length },
                { Metric: 'Total Near Misses', Value: state.nearMiss.filteredData.length },
                { Metric: 'Combined Events', Value: state.injury.filteredData.length + state.nearMiss.filteredData.length },
                { Metric: 'Near Miss to Injury Ratio', Value: state.injury.filteredData.length > 0 ? 
                    (state.nearMiss.filteredData.length / state.injury.filteredData.length).toFixed(1) + ':1' : 
                    state.nearMiss.filteredData.length + ':0' },
                { Metric: 'Date Range', Value: getReportPeriod() },
                ...calculateExecutiveMetrics()
            ].map(item => ({ Metric: item.Metric || item.label || 'Metric', Value: item.Value || item }));
        }

        function exportTable(type) {
            const table = document.getElementById(type === 'injury' ? 'injuryTable' : 'nearMissTable');
            const ws = XLSX.utils.table_to_sheet(table);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'Table Export');
            
            const filename = `${type}_table_export_${new Date().toISOString().split('T')[0]}.xlsx`;
            XLSX.writeFile(wb, filename);
            showStatus('Table exported to Excel', 'success');
        }

        function exportChart(chartId) {
            const canvas = document.getElementById(chartId);
            if (!canvas) {
                showStatus('Chart not found', 'error');
                return;
            }
            
            canvas.toBlob(function(blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${chartId}_${new Date().toISOString().split('T')[0]}.png`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showStatus('Chart exported as image', 'success');
            });
        }

        function exportDashboard() {
            showStatus('Capturing dashboard screenshot...', 'info');
            
            html2canvas(document.querySelector('.container')).then(canvas => {
                canvas.toBlob(function(blob) {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `Safety_Dashboard_${new Date().toISOString().split('T')[0]}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showStatus('Dashboard screenshot saved', 'success');
                });
            });
        }

        // View Details Function
        function viewDetails(type, id) {
            const data = type === 'injury' ? state.injury.filteredData : state.nearMiss.filteredData;
            const record = data.find(r => (r.case_number || r.incident_id) === id);
            
            if (!record) {
                showStatus('Record not found', 'error');
                return;
            }
            
            const modal = document.getElementById('detailModal');
            const title = document.getElementById('modalTitle');
            const body = document.getElementById('modalBody');
            
            title.textContent = type === 'injury' ? 
                `Injury Details: ${record.case_number}` : 
                `Near Miss Details: ${record.incident_id}`;
            
            const details = type === 'injury' ? `
                <div style="display: grid; gap: 1rem;">
                    <div>
                        <strong>Date:</strong> ${record.incident_date || 'N/A'}<br>
                        <strong>Site:</strong> ${record.site || 'N/A'}<br>
                        <strong>Severity:</strong> <span class="badge badge-${getSeverityClass(record.severity)}">${record.severity}</span><br>
                        <strong>Recordable:</strong> <span class="badge badge-${record.recordable === 1 ? 'danger' : 'success'}">${record.recordable === 1 ? 'Yes' : 'No'}</span>
                    </div>
                    <div>
                        <strong>Body Part:</strong> ${record.bodyPart || 'N/A'}<br>
                        <strong>Type:</strong> ${record.type || 'N/A'}<br>
                        <strong>DAFW Days:</strong> ${record.total_dafw_days || 0}<br>
                        <strong>RWA Days:</strong> ${record.total_rwa_days || 0}
                    </div>
                    <div>
                        <strong>Root Cause:</strong> ${record.rootCause || 'Under Investigation'}<br>
                        <strong>Contributing Factor:</strong> ${record.contributingFactor || 'N/A'}<br>
                        <strong>Process Path:</strong> ${record.processPath || 'N/A'}<br>
                        <strong>OTR:</strong> ${record.otr === 'yes' ? 'Yes' : 'No'}
                    </div>
                    <div style="grid-column: 1 / -1;">
                        <strong>Description:</strong><br>
                        <p style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px; margin-top: 0.5rem;">
                            ${record.description || 'No description available'}
                        </p>
                    </div>
                    ${record.incident_url ? `
                        <div style="grid-column: 1 / -1; text-align: center;">
                            <a href="${record.incident_url}" target="_blank" class="btn btn-primary">
                                View in EHS System
                            </a>
                        </div>
                    ` : ''}
                </div>
            ` : `
                <div style="display: grid; gap: 1rem;">
                    <div>
                        <strong>Date:</strong> ${record.nearmiss_date || 'N/A'}<br>
                        <strong>Site:</strong> ${record.site || 'N/A'}<br>
                        <strong>Severity:</strong> <span class="badge badge-${getSeverityClass(record.severity)}">${record.severity}</span><br>
                        <strong>Risk Score:</strong> <span class="badge badge-${getRiskClass(record.risk)}">${record.risk || 'N/A'}</span>
                    </div>
                    <div>
                        <strong>Location:</strong> ${record.location || 'N/A'}<br>
                        <strong>Process Path:</strong> ${record.processPath || 'N/A'}<br>
                        <strong>Primary Impact:</strong> ${record.primaryImpact || 'N/A'}<br>
                        <strong>Likelihood:</strong> ${record.standardized_likelihood || 'N/A'}
                    </div>
                    <div>
                        <strong>Contributing Factor:</strong> ${record.contributingFactor || 'N/A'}<br>
                        <strong>Description Length:</strong> ${record.descriptionLength || 0} characters<br>
                        <strong>Data Complete:</strong> ${record.hasCompleteData ? 'Yes' : 'No'}
                    </div>
                    <div style="grid-column: 1 / -1;">
                        <strong>Description:</strong><br>
                        <p style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px; margin-top: 0.5rem;">
                            ${record.description || 'No description available'}
                        </p>
                    </div>
                    ${record.incident_url ? `
                        <div style="grid-column: 1 / -1; text-align: center;">
                            <a href="${record.incident_url}" target="_blank" class="btn btn-primary">
                                View in EHS System
                            </a>
                        </div>
                    ` : ''}
                </div>
            `;
            
            body.innerHTML = details;
            modal.style.display = 'block';
        }

        // Refresh Dashboard
        function refreshDashboard(type) {
            showStatus('Refreshing dashboard...', 'info');
            
            if (type === 'injury') {
                applyFilters('injury');
                updateInjuryDashboard();
                updateInjuryCharts();
                updateInjuryTable();
            } else {
                applyFilters('nearmiss');
                updateNearMissDashboard();
                updateNearMissCharts();
                updateNearMissTable();
            }
            
            updateOverview();
            
            setTimeout(() => {
                showStatus('Dashboard refreshed', 'success');
            }, 500);
        }

        // Update All Charts (for theme changes)
        function updateAllCharts() {
            // Update all Chart.js instances with new theme
            Chart.helpers.each(Chart.instances, function(instance) {
                instance.options = {
                    ...instance.options,
                    ...getChartOptions(instance.config.type)
                };
                instance.update();
            });
        }

        // Status Messages
        function showStatus(message, type) {
            const container = document.getElementById('statusContainer');
            const statusDiv = document.createElement('div');
            statusDiv.className = `status-message status-${type}`;
            
            let icon = '';
            switch(type) {
                case 'success': icon = '✓'; break;
                case 'error': icon = '✗'; break;
                case 'info': icon = 'ℹ'; break;
            }
            
            statusDiv.innerHTML = `<span style="font-size: 1.2rem;">${icon}</span> ${message}`;
            container.appendChild(statusDiv);
            
            setTimeout(() => {
                statusDiv.style.opacity = '0';
                setTimeout(() => {
                    container.removeChild(statusDiv);
                }, 300);
            }, 3000);
        }

        // Event Listeners
        function setupEventListeners() {
            // Close modal when clicking outside
            window.onclick = function(event) {
                const modal = document.getElementById('detailModal');
                if (event.target === modal) {
                    closeModal();
                }
            };
            
            // Keyboard shortcuts
            document.addEventListener('keydown', function(event) {
                // Ctrl/Cmd + S to save report
                if ((event.ctrlKey || event.metaKey) && event.key === 's') {
                    event.preventDefault();
                    generatePDFReport('combined');
                }
                
                // Escape to close modal
                if (event.key === 'Escape') {
                    closeModal();
                }
            });
        }

        // Load Sample Data
        function loadSampleData() {
            showStatus('Loading sample data...', 'info');
            
            // Sample injury data
            const sampleInjuries = generateSampleInjuryData();
            state.injury.rawData = sampleInjuries;
            processInjuryData();
            populateInjuryFilters();
            applyFilters('injury');
            
            // Sample near miss data
            const sampleNearMisses = generateSampleNearMissData();
            state.nearMiss.rawData = sampleNearMisses;
            processNearMissData();
            populateNearMissFilters();
            applyFilters('nearmiss');
            
            updateOverview();
            showStatus('Sample data loaded successfully!', 'success');
        }

        function generateSampleInjuryData() {
            const sites = ['FC-01', 'FC-02', 'FC-03', 'FC-04', 'FC-05'];
            const bodyParts = ['Back', 'Hand', 'Knee', 'Shoulder', 'Ankle', 'Wrist', 'Head', 'Foot'];
            const severities = ['A', 'B', 'C', 'D'];
            const rootCauses = ['Manual Handling', 'Slip/Trip/Fall', 'Equipment', 'Process', 'Behavior'];
            const processPaths = ['Inbound', 'Outbound', 'Pick', 'Pack', 'Stow', 'Sort'];
            
            const data = [];
            const today = new Date();
            
            for (let i = 0; i < 50; i++) {
                const date = new Date(today);
                date.setDate(date.getDate() - Math.floor(Math.random() * 180));
                
                const severity = severities[Math.floor(Math.random() * severities.length)];
                const recordable = severity === 'A' || severity === 'B' || Math.random() > 0.5 ? 1 : 0;
                const dafwDays = recordable && Math.random() > 0.5 ? Math.floor(Math.random() * 30) : 0;
                
                data.push({
                    case_number: `INJ-2024-${String(i + 1).padStart(4, '0')}`,
                    incident_date: date.toISOString().split('T')[0],
                    site: sites[Math.floor(Math.random() * sites.length)],
                    severity: severity,
                    recordable: recordable,
                    total_dafw_days: dafwDays,
                    total_rwa_days: recordable ? Math.floor(Math.random() * 10) : 0,
                    initial_info_principal_body_part: bodyParts[Math.floor(Math.random() * bodyParts.length)],
                    rca_primary_cause: rootCauses[Math.floor(Math.random() * rootCauses.length)],
                    initial_info_process_path: processPaths[Math.floor(Math.random() * processPaths.length)],
                    initial_info_incident_on_the_road: Math.random() > 0.9,
                    initial_info_incident_description: `Sample injury incident description ${i + 1}. Worker experienced injury while performing standard operations.`,
                    type: 'Injury',
                    rca_contributing_factor_category: 'Human Factors'
                });
            }
            
            return data;
        }

        function generateSampleNearMissData() {
            const sites = ['FC-01', 'FC-02', 'FC-03', 'FC-04', 'FC-05'];
            const locations = ['Dock Area', 'Pick Tower', 'Pack Station', 'Sort Center', 'Break Room', 'Parking Lot'];
            const severities = ['A', 'B', 'C', 'D'];
            const impacts = ['Safety', 'Health', 'Environment', 'Security', 'Quality'];
            const likelihoods = ['Rare', 'Unlikely', 'Possible', 'Likely', 'Almost Certain'];
            const processPaths = ['Inbound', 'Outbound', 'Pick', 'Pack', 'Stow', 'Sort'];
            
            const data = [];
            const today = new Date();
            
            for (let i = 0; i < 100; i++) {
                const date = new Date(today);
                date.setDate(date.getDate() - Math.floor(Math.random() * 180));
                
                const severity = severities[Math.floor(Math.random() * severities.length)];
                const likelihood = likelihoods[Math.floor(Math.random() * likelihoods.length)];
                
                data.push({
                    incident_id: `NM-2024-${String(i + 1).padStart(4, '0')}`,
                    nearmiss_date: date.toISOString().split('T')[0],
                    site: sites[Math.floor(Math.random() * sites.length)],
                    potential_severity: severity,
                    initial_info_location_event: locations[Math.floor(Math.random() * locations.length)],
                    initial_info_primary_impact: impacts[Math.floor(Math.random() * impacts.length)],
                    initial_risk_assessment_likeliness: likelihood,
                    initial_info_process_path: processPaths[Math.floor(Math.random() * processPaths.length)],
                    initial_info_incident_description: `Sample near miss incident description ${i + 1}. Potential hazard identified during routine operations. ${Math.random() > 0.5 ? 'Immediate corrective action taken to prevent injury.' : 'Area secured and reported to supervision.'}`,
                    rca_contributing_factor_category: 'Environmental Factors'
                });
            }
            
            return data;
        }

        // Initialize the application
        console.log('Safety Analytics Platform initialized');
    </script>
</body>
</html>
